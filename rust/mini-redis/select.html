<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Select - M4n5ter Blog</title>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../../theme/style3.css">
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="../../intro/intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="../../go/go.html"><strong aria-hidden="true">2.</strong> GO</a></li><li class="chapter-item expanded "><a href="../../rust/rust.html"><strong aria-hidden="true">3.</strong> RUST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tower/rust_tower.html"><strong aria-hidden="true">3.1.</strong> Tower</a></li><li class="chapter-item expanded "><a href="../../rust/mini-redis/mini-redis.html"><strong aria-hidden="true">3.2.</strong> mini-redis</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/mini-redis/hello_tokio.html"><strong aria-hidden="true">3.2.1.</strong> Hello Tokio</a></li><li class="chapter-item "><a href="../../rust/mini-redis/spawning.html"><strong aria-hidden="true">3.2.2.</strong> Spawning</a></li><li class="chapter-item "><a href="../../rust/mini-redis/shared_state.html"><strong aria-hidden="true">3.2.3.</strong> Shared state</a></li><li class="chapter-item "><a href="../../rust/mini-redis/channels.html"><strong aria-hidden="true">3.2.4.</strong> Channels</a></li><li class="chapter-item "><a href="../../rust/mini-redis/io.html"><strong aria-hidden="true">3.2.5.</strong> I/O</a></li><li class="chapter-item "><a href="../../rust/mini-redis/framing.html"><strong aria-hidden="true">3.2.6.</strong> Framing</a></li><li class="chapter-item "><a href="../../rust/mini-redis/async_in_depth.html"><strong aria-hidden="true">3.2.7.</strong> Async in depth</a></li><li class="chapter-item expanded "><a href="../../rust/mini-redis/select.html" class="active"><strong aria-hidden="true">3.2.8.</strong> Select</a></li><li class="chapter-item "><a href="../../rust/mini-redis/streams.html"><strong aria-hidden="true">3.2.9.</strong> Streams</a></li></ol></li><li class="chapter-item "><a href="../../rust/tokio/tokio.html"><strong aria-hidden="true">3.3.</strong> Tokio</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tokio/topics.html"><strong aria-hidden="true">3.3.1.</strong> Topics TODO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tokio/bridging_with_sync_code.html"><strong aria-hidden="true">3.3.1.1.</strong> Bridging with sync code TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/graceful_shutdown.html"><strong aria-hidden="true">3.3.1.2.</strong> Graceful Shutdown TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/getting_started_with_tracing.html"><strong aria-hidden="true">3.3.1.3.</strong> Getting started with Tracing TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/next_steps_with_tracing.html"><strong aria-hidden="true">3.3.1.4.</strong> Next steps with Tracing TODO</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../other-categories/other-categories.html"><strong aria-hidden="true">4.</strong> Other categories</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../other-categories/archlinux/archlinux.html"><strong aria-hidden="true">4.1.</strong> archlinux</a></li><li class="chapter-item "><a href="../../other-categories/nc/nc.html"><strong aria-hidden="true">4.2.</strong> nmap-netcat(nc)</a></li><li class="chapter-item "><a href="../../other-categories/mkcert/mkcert.html"><strong aria-hidden="true">4.3.</strong> mkcert</a></li><li class="chapter-item "><a href="../../other-categories/aria2/aria2.html"><strong aria-hidden="true">4.4.</strong> aria2</a></li><li class="chapter-item "><a href="../../other-categories/postgres/postgres.html"><strong aria-hidden="true">4.5.</strong> postgres</a></li><li class="chapter-item "><a href="../../other-categories/pre-commit/pre-commit.html"><strong aria-hidden="true">4.6.</strong> pre-commit</a></li><li class="chapter-item "><a href="../../other-categories/minio/minio.html"><strong aria-hidden="true">4.7.</strong> minio</a></li><li class="chapter-item "><a href="../../other-categories/git/git.html"><strong aria-hidden="true">4.8.</strong> git</a></li><li class="chapter-item "><a href="../../other-categories/croc/croc.html"><strong aria-hidden="true">4.9.</strong> croc</a></li></ol></li><li class="chapter-item expanded "><a href="../../blockchain/blockchain.html"><strong aria-hidden="true">5.</strong> Blockchain</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../blockchain/substrate/substrate.html"><strong aria-hidden="true">5.1.</strong> substrate TODO</a></li></ol></li><li class="chapter-item expanded "><a href="../../issues/issues.html"><strong aria-hidden="true">6.</strong> issues and solutions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../issues/docker/docker.html"><strong aria-hidden="true">6.1.</strong> docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../issues/docker/docker_issues.html"><strong aria-hidden="true">6.1.1.</strong> 问题及解决方案</a></li></ol></li><li class="chapter-item "><a href="../../issues/mysql/mysql.html"><strong aria-hidden="true">6.2.</strong> mysql</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../issues/mysql/mysql_issues.html"><strong aria-hidden="true">6.2.1.</strong> 问题及解决方案</a></li></ol></li><li class="chapter-item "><a href="../../issues/gitea/gitea.html"><strong aria-hidden="true">6.3.</strong> gitea</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../issues/gitea/gitea_issues.html"><strong aria-hidden="true">6.3.1.</strong> 问题及解决方案</a></li></ol></li><li class="chapter-item "><a href="../../issues/nginx/nginx.html"><strong aria-hidden="true">6.4.</strong> nginx</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../issues/nginx/nginx_issues.html"><strong aria-hidden="true">6.4.1.</strong> 问题及解决方案</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../links/links.html"><strong aria-hidden="true">7.</strong> Links</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">M4n5ter Blog</h1>

                <div class="right-buttons">
                    <a href="../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/m4n5ter/m4n5ter.github.io" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    <a href="https://github.com/m4n5ter/m4n5ter.github.io/edit/main/src/rust/mini-redis/select.md" title="Suggest an edit" aria-label="Suggest an edit">
                        <i id="git-edit-button" class="fa fa-edit"></i>
                    </a>
                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                // Get viewed page store
                var viewed_key = 'mdbook-viewed';
                var viewed_map = {};
                try {
                    var viewed_storage = localStorage.getItem(viewed_key);
                    if (viewed_storage) {
                        viewed_map = JSON.parse(viewed_storage)
                    }
                } catch (e) { }

                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);

                    // Apply viewed style
                    if (viewed_map[link.pathname]) {
                        link.classList.add('md-viewed')
                    }
                });

                // Mark viewed after 30s
                setTimeout(function () {
                    viewed_map[location.pathname] = 1;
                    localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                }, 30000)
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <h2 id="select"><a class="header" href="#select">Select</a></h2>
<p>目前为止，我们想要为系统增加并发的话，我们需要生成一个新的任务。我们现在将介绍一些其它的方式来使用 Tokio 并发的执行异步代码。</p>
<h2 id="tokioselect"><a class="header" href="#tokioselect"><code>tokio::select!</code></a></h2>
<p>这个 <code>tokio::select!</code> 宏允许在多个异步计算上等待并且在<strong>单个</strong>计算完成时返回。</p>
<p>举个例子：</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    tokio::spawn(async {
        let _ = tx1.send(&quot;one&quot;);
    });

    tokio::spawn(async {
        let _ = tx2.send(&quot;two&quot;);
    });

    tokio::select! {
        val = rx1 =&gt; {
            println!(&quot;rx1 completed first with {:?}&quot;, val);
        }
        val = rx2 =&gt; {
            println!(&quot;rx2 completed first with {:?}&quot;, val);
        }
    }
}
</code></pre></pre>
<p>使用了两个 oneshot channel，它俩中的任何一个都可以第一个完成。<code>select!</code> 语句会在这两个 channel 上 await ，并且绑定 <code>val</code> 到任务的返回值上。当 <code>tx1</code> 或 <code>tx2</code> 完成，相关联的 block 会被执行。</p>
<p><strong>没有</strong>完成的分支会被直接 drop 掉。在这个例子中，计算会 await 在每个 channel 的 <code>oneshot::Receiver</code> 上。没有完成的 <code>oneshot::Receiver</code> 会被丢弃。</p>
<h3 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h3>
<p>在异步 Rust 中，取消表现为 drop 一个 future。回想一下 &quot;<a href="https://m4n5ter.github.io/rust/mini-redis/async_in_depth.html">Async in depth</a>&quot;，异步 Rust 操作通过 future 实现，并且 future 是惰性的。只有 future 被 poll 了，才会有新的进展。如果 future 被 drop 了，那么相关联的状态也会被 drop ，也就是说不会再有新的进展了。</p>
<p>也就是说，有时异步操作会产生后台任务或启动在后台运行的其他操作。举个例子，再上面的示例中，一个任务被创建用来在背后发送消息，一般来说，任务将会执行一些计算来生成值。</p>
<p>Futures 或者其它类型可以实现 <code>Drop</code> 来清理背后的资源。Tokio 的 <code>oneshot::Receiver</code> 通过往 <code>Sender</code> 发送一个关闭信号来实现 <code>Drop</code> 。这个收到关闭信号的 sender 会通过 drop 来中断正在执行的操作。</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::oneshot;

async fn some_operation() -&gt; String {
    // Compute value here
}

#[tokio::main]
async fn main() {
    let (mut tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    tokio::spawn(async {
        // Select on the operation and the oneshot's
        // `closed()` notification.
        tokio::select! {
            val = some_operation() =&gt; {
                let _ = tx1.send(val);
            }
            _ = tx1.closed() =&gt; {
                // `some_operation()` is canceled, the
                // task completes and `tx1` is dropped.
            }
        }
    });

    tokio::spawn(async {
        let _ = tx2.send(&quot;two&quot;);
    });

    tokio::select! {
        val = rx1 =&gt; {
            println!(&quot;rx1 completed first with {:?}&quot;, val);
        }
        val = rx2 =&gt; {
            println!(&quot;rx2 completed first with {:?}&quot;, val);
        }
    }
}
</code></pre></pre>
<h3 id="the-future-implementation"><a class="header" href="#the-future-implementation">The <code>Future</code> implementation</a></h3>
<p>为了更好的理解 <code>select!</code> 的工作方式，让我们看一下假设的 <code>Future</code> 实现会是什么样子。这是一个简化版本，在实践中，<code>select!</code> 包含了其它的功能，例如随机选择第一个被 poll 的分支。</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::oneshot;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct MySelect {
    rx1: oneshot::Receiver&lt;&amp;'static str&gt;,
    rx2: oneshot::Receiver&lt;&amp;'static str&gt;,
}

impl Future for MySelect {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        if let Poll::Ready(val) = Pin::new(&amp;mut self.rx1).poll(cx) {
            println!(&quot;rx1 completed first with {:?}&quot;, val);
            return Poll::Ready(());
        }

        if let Poll::Ready(val) = Pin::new(&amp;mut self.rx2).poll(cx) {
            println!(&quot;rx2 completed first with {:?}&quot;, val);
            return Poll::Ready(());
        }

        Poll::Pending
    }
}

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    // use tx1 and tx2

    MySelect {
        rx1,
        rx2,
    }.await;
}
</code></pre></pre>
<p>这个 <code>MySelect</code> future 包含了每个分支的 future。当 <code>MySelect</code> 被 poll，第一个分支会被 pol，如果它就绪了，它返回出来的 val 就会被用掉，并且 <code>MySelect</code> 会立即结束。在 <code>.await</code> 从 future 收到输出后，future 会被 drop 掉，这导致 future 内的两个分支也会被 drop 。因为有一个分支没有完成，这个分支的操作实际上被取消了。</p>
<p>记住上一节的内容：</p>
<blockquote>
<p>当一个 future 返回 <code>Poll::Pending</code> ，它<strong>必须</strong>确保 waker 是在某一点被注册了。忘记这么做会导致任务被无限期地挂起</p>
</blockquote>
<p>在这个 <code>MySelect</code> 实现中，没有显式的使用 <code>Context</code> 参数。相反，这个 waker 要求通过在内部传递 <code>cx</code> 给内部的 future 满足了。因为内部的 future 也必须满足 waker 要求，通过仅在从内部 future 接收到 <code>Poll::Pending</code> 时返回 <code>Poll::Pending</code> 来满足，所以 <code>MySelect</code> 也满足了 waker 要求。（用我的理解就是 <code>MySelect</code> 靠内部的分支返回 <code>Poll::Ready</code> 时它也返回 <code>Poll::Ready</code> ，内部分支返回 <code>Poll::Pending</code> 时它也返回 <code>Poll::Pending</code> 来隐式的满足了上面引用中的要求 ）</p>
<h2 id="syntax语法"><a class="header" href="#syntax语法">Syntax（语法）</a></h2>
<p>这个 <code>select!</code> 宏可以处理多于两个分支的情况，目前的限制是 64 个分支（可以通过在宏里继续多处理一些分支 ，但是因为 64 个分支已经够多了，一直再宏里增加分支上限也不优雅）。每个分支像这样构成：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;pattern&gt; = &lt;async expression&gt; =&gt; &lt;handler&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>select</code> 宏被执行，所有的 <code>&lt;async expression&gt;</code> 会被聚合起来，然后并发执行。当有一个表达式率先完成，表达式的结果会被匹配到 <code>&lt;pattern&gt;</code> 。如果结果匹配了模式，那么所有剩余的 <code>&lt;async expression&gt;</code> 会被 drop 掉，并且完成了的那个表达式的 <code>&lt;handler&gt;</code> 被执行。<code>&lt;handler&gt;</code> 表达式可以访问 <code>&lt;pattern&gt;</code> 建立的任何绑定。</p>
<p><code>&lt;pattern&gt;</code> 最基本的情况就是一个变量名，<code>&lt;async expression&gt;</code> 的结果会被绑定到这个变量名，并且 <code>&lt;handler&gt;</code> 能访问这个变量。这就是为什么最开始的例子里在 <code>&lt;pattern&gt;</code> 和 <code>&lt;handler&gt;</code> 被使用的 <code>val</code> 是访问的 <code>&lt;async expression&gt;</code> 的 <code>val</code> 。</p>
<p>如果 <code>&lt;pattern&gt;</code> <strong>没有</strong>成功匹配异步计算的结果，那么剩下的异步表达式继续并发执行，直到出现下一个先执行完的 <code>&lt;async expression&gt;</code> 。然后相同的逻辑会继续应用到结果上，以此类推。</p>
<p>因为 <code>select!</code> 可以携带任何异步表达式，所以在 select 上定义更加复杂的计算变得有可能了。</p>
<p>这里，我们 select 一个 <code>oneshot</code> 输出个一个 TCP connection。</p>
<pre><pre class="playground"><code class="language-rust">use tokio::net::TcpStream;
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx, rx) = oneshot::channel();

    // Spawn a task that sends a message over the oneshot
    tokio::spawn(async move {
        tx.send(&quot;done&quot;).unwrap();
    });

    tokio::select! {
        socket = TcpStream::connect(&quot;localhost:3465&quot;) =&gt; {
            println!(&quot;Socket connected {:?}&quot;, socket);
        }
        msg = rx =&gt; {
            println!(&quot;received message first {:?}&quot;, msg);
        }
    }
}
</code></pre></pre>
<p>这里，我们 select 一个 oneshot 和从 <code>TcpListener</code> 接收 sockets 。</p>
<pre><pre class="playground"><code class="language-rust">use tokio::net::TcpListener;
use tokio::sync::oneshot;
use std::io;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let (tx, rx) = oneshot::channel();

    tokio::spawn(async move {
        tx.send(()).unwrap();
    });

    let mut listener = TcpListener::bind(&quot;localhost:3465&quot;).await?;

    tokio::select! {
        _ = async {
            loop {
                let (socket, _) = listener.accept().await?;
                tokio::spawn(async move { process(socket) });
            }

            // Help the rust type inferencer out
            Ok::&lt;_, io::Error&gt;(())
        } =&gt; {}
        _ = rx =&gt; {
            println!(&quot;terminating accept loop&quot;);
        }
    }

    Ok(())
}
</code></pre></pre>
<p>这个 accept loop 会一直运行直到遇到 error 或者 <code>rx</code> 收到一个值。<code>_</code> 模式表示我们对异步计算返回的值并不感兴趣。</p>
<h2 id="return-value"><a class="header" href="#return-value">Return value</a></h2>
<p><code>tokio::select!</code> 宏会返回 <code>&lt;handler&gt;</code> 表达式计算出的结果。</p>
<pre><pre class="playground"><code class="language-rust">async fn computation1() -&gt; String {
    // .. computation
}

async fn computation2() -&gt; String {
    // .. computation
}

#[tokio::main]
async fn main() {
    let out = tokio::select! {
        res1 = computation1() =&gt; res1,
        res2 = computation2() =&gt; res2,
    };

    println!(&quot;Got = {}&quot;, out);
}
</code></pre></pre>
<p>因为这个，它要求<strong>每个</strong>分支的 <code>&lt;handler&gt;</code> 表达式计算出同样的类型。如果 <code>select!</code> 的输出不被需要，一个不错的实践是让表达式返回 <code>()</code></p>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>使用 <code>?</code> 操作符从表达式传播错误。它如何工作取决于 <code>?</code> 是从异步表达式还是从 handler 使用。在异步表达式中使用 <code>?</code> 把错误从异步表达式中传播出去，这会使这个异步表达式的输出变成 <code>Result</code> 。在 handler 中使用 <code>?</code> 会立即将错误传播到 <code>select!</code> 表达式外部。让我们再来看看这个 accpet loop ：</p>
<pre><pre class="playground"><code class="language-rust">use tokio::net::TcpListener;
use tokio::sync::oneshot;
use std::io;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    // [setup `rx` oneshot channel]

    let listener = TcpListener::bind(&quot;localhost:3465&quot;).await?;

    tokio::select! {
        res = async {
            loop {
                let (socket, _) = listener.accept().await?;
                tokio::spawn(async move { process(socket) });
            }

            // Help the rust type inferencer out
            Ok::&lt;_, io::Error&gt;(())
        } =&gt; {
            res?;
        }
        _ = rx =&gt; {
            println!(&quot;terminating accept loop&quot;);
        }
    }

    Ok(())
}
</code></pre></pre>
<p>请关注 <code>listener.accept().await?</code> 。这个 <code>?</code> 操作符把错误传播出了 <code>&lt;async expression&gt;</code> 并且绑定到了 <code>res</code> 。发生错误时 <code>res</code> 会被设置成 <code>Err(_)</code> ，然后在 handler 中，<code>?</code> 操作符再次被使用，<code>res?</code> 语句会把错误传播出 <code>main</code> 函数。</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h2>
<p>回顾一下 <code>select!</code> 宏的分支语法定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;pattern&gt; = &lt;async expression&gt; =&gt; &lt;handler&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>目前为止，我们仅仅在 <code>&lt;pattern&gt;</code> 上使用了变量绑定。然而，任何 Rust 模式都可以被使用，举个例子，如果说我们从多个 MPSC channels 接收，我们可能会这么做：</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (mut tx1, mut rx1) = mpsc::channel(128);
    let (mut tx2, mut rx2) = mpsc::channel(128);

    tokio::spawn(async move {
        // Do something w/ `tx1` and `tx2`
    });

    tokio::select! {
        Some(v) = rx1.recv() =&gt; {
            println!(&quot;Got {:?} from rx1&quot;, v);
        }
        Some(v) = rx2.recv() =&gt; {
            println!(&quot;Got {:?} from rx2&quot;, v);
        }
        else =&gt; {
            println!(&quot;Both channels closed&quot;);
        }
    }
}
</code></pre></pre>
<p>在这个例子中， <code>select!</code> 表达式等待从 <code>rx1</code> 和 <code>rx2</code> 接收一个 value 。如果一个 channel 关闭了，<code>recv()</code> 会返回 <code>None</code> ，这将<strong>无法</strong>匹配例子中的模式，并且当前分支会被禁用。这个 <code>select!</code> 表达式将会继续在剩余的分支上 wait 。</p>
<p>请注意例子中的 <code>select!</code> 表达式包含一个 <code>else</code> 分支。这个 <code>select!</code> 表达式必须计算出一个 value，当使用模式匹配，可能<strong>没有</strong>一条分支能成功匹配它们所关联的模式，如果这种情况发生了， <code>else</code> 分支就会被计算。</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>当生成任务时，生成的异步表达式必须拥有它里面的数据的所有权。但是 <code>select!</code> 宏没有这个限制，每条分支的异步表达式可能是<strong>借用</strong>的数据并且进行并发操作。遵循 Rust  的借用规则，多个异步表达式可以一起<strong>不可变借用</strong>单个数据或者单个异步表达式可以<strong>可变借用</strong>单个数据。</p>
<p>让我们看一下几个例子。这里，我们同时发送相同的数据到两个不同的 TCP 目标。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;
use std::io;
use std::net::SocketAddr;

async fn race(
    data: &amp;[u8],
    addr1: SocketAddr,
    addr2: SocketAddr
) -&gt; io::Result&lt;()&gt; {
    tokio::select! {
        Ok(_) = async {
            let mut socket = TcpStream::connect(addr1).await?;
            socket.write_all(data).await?;
            Ok::&lt;_, io::Error&gt;(())
        } =&gt; {}
        Ok(_) = async {
            let mut socket = TcpStream::connect(addr2).await?;
            socket.write_all(data).await?;
            Ok::&lt;_, io::Error&gt;(())
        } =&gt; {}
        else =&gt; {}
    };

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>这里的 <code>data</code> 变量是被下面的两个异步表达式<strong>不可变借用</strong>的。当其中一个操作成功完成，另一个将会被 drop。因为我们使用 <code>Ok(_)</code> 来模式匹配，如果一个表达式失败了，另一个会继续执行。</p>
<p>当来到每条分支的 <code>&lt;handler&gt;</code> ，<code>select!</code> 保证只有单个 <code>&lt;handler&gt;</code> 会运行。正因如此，每个 <code>&lt;handler&gt;</code> 可以<strong>不可变借用</strong>相同的数据。</p>
<p>下面这个例子在两个 handler 中都对 <code>out</code> 进行了修改：</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx1, rx1) = oneshot::channel();
    let (tx2, rx2) = oneshot::channel();

    let mut out = String::new();

    tokio::spawn(async move {
        // Send values on `tx1` and `tx2`.
    });

    tokio::select! {
        _ = rx1 =&gt; {
            out.push_str(&quot;rx1 completed&quot;);
        }
        _ = rx2 =&gt; {
            out.push_str(&quot;rx2 completed&quot;);
        }
    }

    println!(&quot;{}&quot;, out);
}
</code></pre></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p><code>select!</code> 宏经常被用在循环中。这一部分将会通过几个示例来展示在循环中使用 <code>select!</code> 宏的常见方式。我们通过 select 多个 channels 开始：</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx1, mut rx1) = mpsc::channel(128);
    let (tx2, mut rx2) = mpsc::channel(128);
    let (tx3, mut rx3) = mpsc::channel(128);

    loop {
        let msg = tokio::select! {
            Some(msg) = rx1.recv() =&gt; msg,
            Some(msg) = rx2.recv() =&gt; msg,
            Some(msg) = rx3.recv() =&gt; msg,
            else =&gt; { break }
        };

        println!(&quot;Got {:?}&quot;, msg);
    }

    println!(&quot;All channels have been closed.&quot;);
}
</code></pre></pre>
<p>这个例子在三个 channel 的 rx 上select。当从任意一个 channel 中接收到一条消息，会将其打印到 STDOUT 。当有一条 channel close 了， <code>recv()</code> 会返回 <code>None</code> ，通过使用模式匹配，<code>select!</code> 宏会继续在剩余的 channels 上等待。当所有的 channel 都 close 了，这里的 <code>else</code> 分支会被计算，并且循环会终止。</p>
<p><code>select!</code> 宏随机选中分支来先检查一下是否就绪。当多个 channel 挂起了它们的 value，一个随机的 channel 会被选中，并从它上面接收值。这是为了处理 receive loop 处理消息的速度比消息被推进 channel 的速度慢的情况，意味着 channel 开始被填满了。如果 <code>select!</code> <strong>没有</strong>随机选中一个分支来第一个检查，那么每次循环在迭代的时候， <code>rx1</code> 都会被第一个检查，如果 <code>rx1</code> 总是持有新消息，那么剩余的 channel 永远都不会被检查。</p>
<blockquote>
<p>如果当 <code>select!</code> 被计算时，多个 channel 都有挂起的值，只有一个 channel 能有值被 pop 出去。所有其它的 channel 保持未被接触（没轮到它们），并且它们的消息会留在 channel 中直到下一次循环迭代。不会有消息丢失。</p>
</blockquote>
<h3 id="resuming-an-async-operation恢复异步操作"><a class="header" href="#resuming-an-async-operation恢复异步操作">Resuming an async operation（恢复异步操作）</a></h3>
<p>现在我们将会展示如何跨多个 <code>select!</code> 调用运行异步操作。在这个例子中，我们有一个 消息类型是 <code>i32</code> 的 MPSC channel ，还有一个异步函数。我们希望运行这个异步函数直到它完成或者一个偶数从 channel 中被接收。</p>
<pre><pre class="playground"><code class="language-rust">async fn action() {
    // Some asynchronous logic
}

#[tokio::main]
async fn main() {
    let (mut tx, mut rx) = tokio::sync::mpsc::channel(128);    

    let operation = action();
    tokio::pin!(operation);

    loop {
        tokio::select! {
            _ = &amp;mut operation =&gt; break,
            Some(v) = rx.recv() =&gt; {
                if v % 2 == 0 {
                    break;
                }
            }
        }
    }
}
</code></pre></pre>
<p>请注意，与在 <code>select!</code> 宏内调用 <code>action()</code> 不同，它在循环<strong>外部</strong>被调用。<code>action()</code> 的返回值被分配到了 <code>operation</code> 且<strong>没有</strong>调用 <code>.await</code> 。然后我们对 <code>operation</code> 调用了 <code>tokio::pin!</code> 。</p>
<p>在 <code>select!</code> 循环内，与传入 <code>operation</code> 不同，我们传入了 <code>&amp;mut operation</code> 。这个 <code>operation</code> 变量正在跟踪执行中的异步操作。每次循环迭代使用这个相同的 operation 而不是来一次新的 <code>action()</code> 调用。</p>
<p><code>select!</code> 的另一个分支从 channel 接收消息，如果消息是一个偶数，我们就结束循环。否则，再次开始 <code>select!</code> </p>
<p>这是我们第一次使用 <code>tokio::pin!</code> ，我们还没打算深挖这它的细节。只需要注意，对一个引用进行 <code>.await</code> 调用，这个被引用的值必须被 pin 或者实现了 <code>Unpin</code> 。</p>
<p>如果我们移除 <code>tokio::pin!</code> 这一行，并且尝试编译，我们会得到以下错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0599]: no method named `poll` found for struct
     `std::pin::Pin&lt;&amp;mut &amp;mut impl std::future::Future&gt;`
     in the current scope
  --&gt; src/main.rs:16:9
   |
16 | /         tokio::select! {
17 | |             _ = &amp;mut operation =&gt; break,
18 | |             Some(v) = rx.recv() =&gt; {
19 | |                 if v % 2 == 0 {
...  |
22 | |             }
23 | |         }
   | |_________^ method not found in
   |             `std::pin::Pin&lt;&amp;mut &amp;mut impl std::future::Future&gt;`
   |
   = note: the method `poll` exists but the following trait bounds
            were not satisfied:
           `impl std::future::Future: std::marker::Unpin`
           which is required by
           `&amp;mut impl std::future::Future: std::future::Future`
<span class="boring">}
</span></code></pre></pre>
<p>尽管我们已经在 <a href="https://m4n5ter.github.io/rust/mini-redis/async_in_depth.html">Async in depth</a> 了解了 <code>Future</code> ，但是这个错误对我们来说仍然不是很清晰。如果你在尝试对一个<strong>reference</strong> 调用 <code>.await</code> 时碰到了这样的一个关于 &quot; <code>Future</code> 没有实现... &quot; 的错误，那么这个 future 可能需要被 pin 。</p>
<p>从 <a href="https://doc.rust-lang.org/std/pin/index.html">standard library</a> 阅读更多关于 <a href="https://doc.rust-lang.org/std/pin/index.html"><code>Pin</code></a> 的细节。</p>
<h3 id="modifying-a-branch"><a class="header" href="#modifying-a-branch">Modifying a branch</a></h3>
<p>让我们看一个稍微复杂一些的 loop。我们有：</p>
<ol>
<li>
<p>一个内容是 <code>i32</code> 的 channel。</p>
</li>
<li>
<p>一个对 <code>i32</code> 执行的异步操作。</p>
</li>
</ol>
<p>我们想要实现的逻辑是：</p>
<ol>
<li>
<p>在 channel 上等待一个<strong>偶数</strong></p>
</li>
<li>
<p>使用这个偶数作为输入来开始一个异步操作。</p>
</li>
<li>
<p>等待这个异步操作，但是同时要从 channel 监听更多的偶数。</p>
</li>
<li>
<p>如果一个新的偶数在已经存在的异步操作完成之前被接收到了，退出存在的异步操作并且用新的偶数再跑一个。</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust">async fn action(input: Option&lt;i32&gt;) -&gt; Option&lt;String&gt; {
    // If the input is `None`, return `None`.
    // This could also be written as `let i = input?;`
    let i = match input {
        Some(input) =&gt; input,
        None =&gt; return None,
    };
    // async logic here
}

#[tokio::main]
async fn main() {
    let (mut tx, mut rx) = tokio::sync::mpsc::channel(128);

    let mut done = false;
    let operation = action(None);
    tokio::pin!(operation);

    tokio::spawn(async move {
        let _ = tx.send(1).await;
        let _ = tx.send(3).await;
        let _ = tx.send(2).await;
    });

    loop {
        tokio::select! {
            res = &amp;mut operation, if !done =&gt; {
                done = true;

                if let Some(v) = res {
                    println!(&quot;GOT = {}&quot;, v);
                    return;
                }
            }
            Some(v) = rx.recv() =&gt; {
                if v % 2 == 0 {
                    // `.set` is a method on `Pin`.
                    operation.set(action(Some(v)));
                    done = false;
                }
            }
        }
    }
}
</code></pre></pre>
<p>我们使用了和之前那个例子相似的方法。这个异步函数在循环外被调用，并且分配到 <code>operation</code> 。这个 <code>operation</code> 变量被 pin 了。这个循环会在 <code>operation</code> 和 channel receiver 上 select 。</p>
<p>请注意 <code>action</code> 是如何携带 <code>Option&lt;i32&gt;</code> 作为一个参数的。在我们接收到第一个偶数之前，我们需要实例化一个 <code>operation</code> 。我们使 <code>action</code> 携带 <code>Option</code> 并且返回 <code>Option</code> 。如果 <code>None</code> 被传递进去了，会返回  <code>None</code> 。第一次循环迭代， <code>operation</code> 会立即完成并返回 <code>None</code> （因为我们实例化它的时候穿的是 <code>None</code>）。</p>
<p>这个例子使用了一些新语法。这第一个分支包括 <code>,if !done</code> ，这是一个分支先决条件。在解释它是如何工作的之前，让我们看下如果省略这个先决条件会发生什么。移除 <code>,if !done</code> 并且运行例子会导致以下输出：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' panicked at '`async fn` resumed after completion', src/main.rs:1:55
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
<span class="boring">}
</span></code></pre></pre>
<p>当尝试在 <code>operation</code> 已经完成<strong>之后</strong>使用它时，这个错误发生了。一般来说，当使用 <code>.await</code> ，这个被 await 的值就被消费掉了。在这个例子中，我们 await 了一个引用，这意味着 <code>operation</code> 在它完成后仍然存在。</p>
<p>为了避免这个 panic，如果 <code>operation</code> 已经完成，我们必须小心地禁用第一条分支。这里的 <code>done</code> 变量被用来跟踪 <code>operation</code> 是否完成。一个 <code>select!</code> 分支可能会包含一个 <strong>precondition</strong> （先决条件），这个先决条件会在 <code>select!</code> await 当前分支<strong>之前</strong>被检查（虽然顺序上它被写在后面，但是不影响它是一个 &quot;先决条件&quot;）。如果先决条件计算出了 <code>false</code> 那么该分支会被禁用。<code>done</code> 变量被初始化为 <code>false</code> 。当 <code>operation</code> 完成，<code>done</code> 会被设置为 <code>true</code> ，这样在下次循环迭代的时候将会禁用 <code>operation</code> 分支。当一个偶数消息从 channel 被接收，<code>operation</code> 会被重置，并且 <code>done</code> 会被设置为 <code>false</code> 。</p>
<h2 id="per-task-concurrency"><a class="header" href="#per-task-concurrency">Per-task concurrency</a></h2>
<p><code>tokio::spawn</code> 和 <code>select!</code> 都能够运行并发的异步操作。然而，运行并发操作的策略有所不同。<code>tokio::spawn</code> 函数携带一个异步操作，并且生成一个新的任务去运行它。一个任务是 Tokio runtime 调度的对象。两个不同的任务会被 Tokio 独立调度，它们可能会同时运行在不同的操作系统线程上。正因如此，一个被生成的任务和被生成的线程具有相同的限制：不能有借用！</p>
<p><code>select!</code> 宏会在<strong>同一个任务</strong>中并发运行所有的分支。因为所有的 <code>select!</code> 分支都在同一个任务中被执行，它们永远不可能<strong>同时</strong>被运行。<code>select!</code> 宏会在单个任务上多路复用异步操作。</p>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../rust/mini-redis/async_in_depth.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../rust/mini-redis/streams.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../rust/mini-redis/async_in_depth.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            <a rel="next" href="../../rust/mini-redis/streams.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "rust/mini-redis/select.md"
    </script>


    <!-- Custom JS scripts -->
    <script type="text/javascript" src="../../assets/custom.js"></script>
    <script type="text/javascript" src="../../assets/bigPicture.js"></script>
</body>

</html>