<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Async in depth - M4n5ter Blog</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../../theme/style3.css">


</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="../../intro/intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="../../go/go.html"><strong aria-hidden="true">2.</strong> GO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../go/gin_zo.html"><strong aria-hidden="true">2.1.</strong> Gin + ZincObserve</a></li></ol></li><li class="chapter-item expanded "><a href="../../rust/rust.html"><strong aria-hidden="true">3.</strong> RUST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tower/rust_tower.html"><strong aria-hidden="true">3.1.</strong> Tower</a></li><li class="chapter-item expanded "><a href="../../rust/mini-redis/mini-redis.html"><strong aria-hidden="true">3.2.</strong> mini-redis</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/mini-redis/hello_tokio.html"><strong aria-hidden="true">3.2.1.</strong> Hello Tokio</a></li><li class="chapter-item "><a href="../../rust/mini-redis/spawning.html"><strong aria-hidden="true">3.2.2.</strong> Spawning</a></li><li class="chapter-item "><a href="../../rust/mini-redis/shared_state.html"><strong aria-hidden="true">3.2.3.</strong> Shared state</a></li><li class="chapter-item "><a href="../../rust/mini-redis/channels.html"><strong aria-hidden="true">3.2.4.</strong> Channels</a></li><li class="chapter-item "><a href="../../rust/mini-redis/io.html"><strong aria-hidden="true">3.2.5.</strong> I/O</a></li><li class="chapter-item "><a href="../../rust/mini-redis/framing.html"><strong aria-hidden="true">3.2.6.</strong> Framing</a></li><li class="chapter-item expanded "><a href="../../rust/mini-redis/async_in_depth.html" class="active"><strong aria-hidden="true">3.2.7.</strong> Async in depth</a></li><li class="chapter-item "><a href="../../rust/mini-redis/select.html"><strong aria-hidden="true">3.2.8.</strong> Select</a></li><li class="chapter-item "><a href="../../rust/mini-redis/streams.html"><strong aria-hidden="true">3.2.9.</strong> Streams</a></li></ol></li><li class="chapter-item "><a href="../../rust/tokio/tokio.html"><strong aria-hidden="true">3.3.</strong> Tokio</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tokio/topics.html"><strong aria-hidden="true">3.3.1.</strong> Topics TODO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tokio/bridging_with_sync_code.html"><strong aria-hidden="true">3.3.1.1.</strong> Bridging with sync code TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/graceful_shutdown.html"><strong aria-hidden="true">3.3.1.2.</strong> Graceful Shutdown TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/getting_started_with_tracing.html"><strong aria-hidden="true">3.3.1.3.</strong> Getting started with Tracing TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/next_steps_with_tracing.html"><strong aria-hidden="true">3.3.1.4.</strong> Next steps with Tracing TODO</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../other-categories/other-categories.html"><strong aria-hidden="true">4.</strong> Other categories</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../other-categories/archlinux/archlinux.html"><strong aria-hidden="true">4.1.</strong> archlinux</a></li><li class="chapter-item "><a href="../../other-categories/algorithm/algorithm.html"><strong aria-hidden="true">4.2.</strong> algorithm</a></li><li class="chapter-item "><a href="../../other-categories/nc/nc.html"><strong aria-hidden="true">4.3.</strong> nmap-netcat(nc)</a></li><li class="chapter-item "><a href="../../other-categories/mkcert/mkcert.html"><strong aria-hidden="true">4.4.</strong> mkcert</a></li><li class="chapter-item "><a href="../../other-categories/aria2/aria2.html"><strong aria-hidden="true">4.5.</strong> aria2</a></li><li class="chapter-item "><a href="../../other-categories/postgres/postgres.html"><strong aria-hidden="true">4.6.</strong> postgres</a></li><li class="chapter-item "><a href="../../other-categories/pre-commit/pre-commit.html"><strong aria-hidden="true">4.7.</strong> pre-commit</a></li><li class="chapter-item "><a href="../../other-categories/minio/minio.html"><strong aria-hidden="true">4.8.</strong> minio</a></li><li class="chapter-item "><a href="../../other-categories/git/git.html"><strong aria-hidden="true">4.9.</strong> git</a></li><li class="chapter-item "><a href="../../other-categories/croc/croc.html"><strong aria-hidden="true">4.10.</strong> croc</a></li></ol></li><li class="chapter-item expanded "><a href="../../blockchain/blockchain.html"><strong aria-hidden="true">5.</strong> Blockchain</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../blockchain/substrate/substrate.html"><strong aria-hidden="true">5.1.</strong> substrate TODO</a></li></ol></li><li class="chapter-item expanded "><a href="../../issues/issues.html"><strong aria-hidden="true">6.</strong> issues and solutions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../isuues/linux/linux_issues.html"><strong aria-hidden="true">6.1.</strong> linux</a></li><li class="chapter-item "><a href="../../issues/docker/docker_issues.html"><strong aria-hidden="true">6.2.</strong> docker</a></li><li class="chapter-item "><a href="../../issues/mysql/mysql_issues.html"><strong aria-hidden="true">6.3.</strong> mysql</a></li><li class="chapter-item "><a href="../../issues/gitea/gitea_issues.html"><strong aria-hidden="true">6.4.</strong> gitea</a></li><li class="chapter-item "><a href="../../issues/nginx/nginx_issues.html"><strong aria-hidden="true">6.5.</strong> nginx</a></li></ol></li><li class="chapter-item expanded "><a href="../../links/links.html"><strong aria-hidden="true">7.</strong> Links</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">M4n5ter Blog</h1>

                <div class="right-buttons">
                    <a href="../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/m4n5ter/m4n5ter.github.io" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    <a href="https://github.com/m4n5ter/m4n5ter.github.io/edit/main/src/rust/mini-redis/async_in_depth.md" title="Suggest an edit" aria-label="Suggest an edit">
                        <i id="git-edit-button" class="fa fa-edit"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                // Get viewed page store
                var viewed_key = 'mdbook-viewed';
                var viewed_map = {};
                try {
                    var viewed_storage = localStorage.getItem(viewed_key);
                    if (viewed_storage) {
                        viewed_map = JSON.parse(viewed_storage)
                    }
                } catch (e) { }

                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);

                    // Apply viewed style
                    if (viewed_map[link.pathname]) {
                        link.classList.add('md-viewed')
                    }
                });

                // Mark viewed after 30s
                setTimeout(function () {
                    viewed_map[location.pathname] = 1;
                    localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                }, 30000)
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <h2 id="async-in-depth-深入异步"><a class="header" href="#async-in-depth-深入异步">Async in depth （深入异步）</a></h2>
<p>至此，我们已经完成了一个相当全面的异步 Rust 和 Tokio 之旅。现在我们将会深挖 Rust 的异步运行时模型。在本教程的开始，我们就提到了 异步 Rust 用了一种独一无二的方法。现在我们来解释一下是啥意思。</p>
<h2 id="futures"><a class="header" href="#futures">Futures</a></h2>
<p>作为快速回顾，我们来举一个非常基本的异步函数。与教程到目前为止所涵盖的内容相比，这并不是什么新鲜事。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpStream;

async fn my_async_fn() {
    println!(&quot;hello from async&quot;);
    let _socket = TcpStream::connect(&quot;127.0.0.1:3000&quot;).await.unwrap();
    println!(&quot;async TCP operation complete&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>我们调用了这个函数，并且返回了某个值，对这个值调用 <code>.await</code>。</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let what_is_this = my_async_fn();
    // Nothing has been printed yet.
    what_is_this.await;
    // Text has been printed and socket has been
    // established and closed.
}</code></pre></pre>
<p><code>my_async_fn()</code> 返回的值是一个 future ，future 是一个实现了标准库提供的  <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>std::future::Future</code></a> trait 的值。它们是包含正在进行的异步计算的值。</p>
<p> <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>std::future::Future</code></a> trait 的定义如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context)
        -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>关联类型( <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">associated type</a> ) <code>Output</code> 是 future 一旦完成后会产生的类型。可以通过看标准库文档（<a href="https://doc.rust-lang.org/std/pin/index.html">standard library</a>）得到更多细节。</p>
<p>不像其它语言实现的 future ，一个 Rust 的 future 不是代表一个正在后台发生的计算，而是 Rust future 就是计算本身。future 的所有者负责通过 poll the future 来推动计算，这就是 <code>Future::poll</code> 所做的事。</p>
<h3 id="implementing-future-实现-future"><a class="header" href="#implementing-future-实现-future">Implementing <code>Future</code> （实现 <code>Future</code>）</a></h3>
<p>让我们实现一个简单的 future。这个 future 将会：</p>
<ol>
<li>
<p>一直 wait 到特定时刻。</p>
</li>
<li>
<p>输出一些文本到 STDOUT 。</p>
</li>
<li>
<p>产生一个字符串。</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust">use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
}

impl Future for Delay {
    type Output = &amp;'static str;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;&amp;'static str&gt;
    {
        if Instant::now() &gt;= self.when {
            println!(&quot;Hello world&quot;);
            Poll::Ready(&quot;done&quot;)
        } else {
            // Ignore this line for now.
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}

#[tokio::main]
async fn main() {
    let when = Instant::now() + Duration::from_millis(10);
    let future = Delay { when };

    let out = future.await;
    assert_eq!(out, &quot;done&quot;);
}</code></pre></pre>
<h3 id="async-fn-as-a-future-异步函数作为-future"><a class="header" href="#async-fn-as-a-future-异步函数作为-future">Async fn as a Future （异步函数作为 future）</a></h3>
<p>在 main 函数中，我们实例化一个 future 并对它调用 <code>.await</code> 。在异步函数中，我们可以对任何实现了 <code>Future</code> 的值调用 <code>.await</code> 。相反，调用一个 <code>async</code> function 返回一个实现了 <code>Future</code> 的匿名类型。<code>async fn main()</code> 所生成的 future 类似于：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

enum MainFuture {
    // Initialized, never polled
    State0,
    // Waiting on `Delay`, i.e. the `future.await` line.
    State1(Delay),
    // The future has completed.
    Terminated,
}

impl Future for MainFuture {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;()&gt;
    {
        use MainFuture::*;

        loop {
            match *self {
                State0 =&gt; {
                    let when = Instant::now() +
                        Duration::from_millis(10);
                    let future = Delay { when };
                    *self = State1(future);
                }
                State1(ref mut my_future) =&gt; {
                    match Pin::new(my_future).poll(cx) {
                        Poll::Ready(out) =&gt; {
                            assert_eq!(out, &quot;done&quot;);
                            *self = Terminated;
                            return Poll::Ready(());
                        }
                        Poll::Pending =&gt; {
                            return Poll::Pending;
                        }
                    }
                }
                Terminated =&gt; {
                    panic!(&quot;future polled after completion&quot;)
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust 的 future 是<strong>状态机</strong>(<code>state machine</code>) 。此处，<code>MainFuture</code> 代表着由一个 future 可能的状态构成的 <code>enum</code> 。这个 future 从 <code>State0</code> 状态开始，当 <code>poll</code> 被调用时，这个 future 会尽可能地尝试推动其内部的状态。如果这个 future 能够完成了，<code>Poll::Ready</code> 会返回它包含的异步计算的输出结果。</p>
<p>如果这个 future <strong>不</strong>能够完成，通常是由于资源问题，这种情况它一般还在等着被调度，等着变成 <code>Poll::Ready</code> ，这时会返回 <code>Poll::Pending</code> 表示 future 还没完成。收到 <code>Poll::Pending</code> 表示告诉 future 的调用者，这个 future 将会在之后一段时间被完成，并且调用者应该在之后再次调用 <code>poll</code> 。</p>
<p>我们也看到了 future 由 其他 future 构成（future 可以嵌套）。对外层的 future 调用 <code>poll</code> 会导致内部的 future 的 <code>poll</code> 函数也被调用。</p>
<h2 id="executor-执行者一般就是运行时了"><a class="header" href="#executor-执行者一般就是运行时了">Executor （执行者，一般就是运行时了）</a></h2>
<p>异步 Rust 函数会返回 future ，而 future 又必须通过调用它们身上的 <code>poll</code> 来推进它们的状态，future 又由其它 future 组成。因此，问题来了，谁来调用最最最外层的 future 的 <code>poll</code> 呢？</p>
<p>回顾之前的内容，为了运行异步函数，它们也必须被传递给 <code>tokio::spawn</code> 或者 main 函数被用 <code>#[tokio::main]</code> 注释。这都会把生成的外层 future 提交给 Tokio executor ，这个 executor 负责调用外层 future 的 <code>Future::poll</code> 来驱动异步计算完成。</p>
<h3 id="mini-tokio"><a class="header" href="#mini-tokio">Mini Tokio</a></h3>
<p>为了更好地理解这一切是如何结合在一起的，让我们实现我们自己的 minimal version Tokio！ 完整代码能在<a href="https://github.com/tokio-rs/website/blob/master/tutorial-code/mini-tokio/src/main.rs">这里</a>被找到。</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use futures::task;

fn main() {
    let mut mini_tokio = MiniTokio::new();

    mini_tokio.spawn(async {
        let when = Instant::now() + Duration::from_millis(10);
        let future = Delay { when };

        let out = future.await;
        assert_eq!(out, &quot;done&quot;);
    });

    mini_tokio.run();
}

struct MiniTokio {
    tasks: VecDeque&lt;Task&gt;,
}

type Task = Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + Send&gt;&gt;;

impl MiniTokio {
    fn new() -&gt; MiniTokio {
        MiniTokio {
            tasks: VecDeque::new(),
        }
    }

    /// Spawn a future onto the mini-tokio instance.
    fn spawn&lt;F&gt;(&amp;mut self, future: F)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        self.tasks.push_back(Box::pin(future));
    }

    fn run(&amp;mut self) {
        let waker = task::noop_waker();
        let mut cx = Context::from_waker(&amp;waker);

        while let Some(mut task) = self.tasks.pop_front() {
            if task.as_mut().poll(&amp;mut cx).is_pending() {
                self.tasks.push_back(task);
            }
        }
    }
}</code></pre></pre>
<p>运行了一个 async block，使用自定义的 delay  创建了一个 <code>Delay</code> future 实例并且调用了 <code>.await</code> 。然而，我们的目前为止的实现有一个重大的<strong>污点</strong>，那就是我们的执行者永远不会 sleep，执行者在持续不断的循环所有生成的 future 并且 poll 它们。大多数时候，future 们都没有准备好执行更多的工作并且会再次返回 <code>Poll:Pending</code> （所以应该需要有一定的间隔，而不是没有 sleep 的无限循环去 poll）。这个过程会大量消耗 CPU 资源并且通常并不高效。</p>
<p>理想情况下，我们希望 mini-tokio 只在 future 能够取得进展时才进行 poll 。这种情况会发生在当任务被阻塞时的资源准备好去执行被请求的操作的时候。如果任务想要从一个 TCP socket 读取数据，那么我们只希望当 TCP socket 已经接收到数据的时候才去 poll 任务（而不是 socket 里啥都没有的时候去疯狂 poll） 。在我们的场景下，任务被阻塞直到给出的 <code>Istant</code> 到达，理想情况下，mini-tokio 应该只在那一时刻刚过后去 poll 任务。</p>
<p>为了实现这个目的，当一个资源被 poll，并且这个资源<strong>没有</strong>准备好时，这个资源将会在它转变成 ready state 的时候主动发送一个通知。</p>
<h2 id="wakers-唤醒者"><a class="header" href="#wakers-唤醒者">Wakers （唤醒者）</a></h2>
<p>Waker 是缺失的部分，这是资源能够通知正在等待的任务资源已准备好继续某些操作的一个系统（换句话说就是 waker 负责通知外面等我的那个任务，告诉它我准备好了，来 poll 我吧）。</p>
<p>让我们再看看 <code>Future::poll</code> 的定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context)
    -&gt; Poll&lt;Self::Output&gt;;
<span class="boring">}</span></code></pre></pre>
<p>可以发现想要 poll future 的时候需要携带一个 <a href="https://doc.rust-lang.org/std/task/struct.Context.html"><code>Context</code></a> ，而它有一个 <code>waker()</code> 方法，这个方法返回一个 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a> 绑定到当前任务。这个 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a> 有一个 <code>wake()</code> 方法，这个方法正是我们要的，调用这个方法会发送信号给 executor，表示相关联的任务应该被调度来执行了。当资源转变成 ready state 的时候调用 <code>wake()</code> 方法来通知 executor 可以 poll 任务来获取进展。</p>
<h3 id="updating-delay"><a class="header" href="#updating-delay">Updating <code>Delay</code></a></h3>
<p>我们可以更新 <code>Delay</code> 来使用 wakers ：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use std::thread;

struct Delay {
    when: Instant,
}

impl Future for Delay {
    type Output = &amp;'static str;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;&amp;'static str&gt;
    {
        if Instant::now() &gt;= self.when {
            println!(&quot;Hello world&quot;);
            Poll::Ready(&quot;done&quot;)
        } else {
            // Get a handle to the waker for the current task
            let waker = cx.waker().clone();
            let when = self.when;

            // Spawn a timer thread.
            thread::spawn(move || {
                let now = Instant::now();

                if now &lt; when {
                    thread::sleep(when - now);
                }

                waker.wake();
            });

            Poll::Pending
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>现在，一旦指定的时间到了，调用的任务会通知 executor 并且 executor 能够确保任务再次被调度。下一步就是更新 mini-tokio 来监听 wake notifications（通知）。</p>
<p>这里我们的 <code>Delay</code> 实现仍然留有一些问题。我们将会在后面修复它们。</p>
<blockquote>
<p>当一个 future 返回 <code>Poll::Pending</code> ，它<strong>必须</strong>确保 waker 是在某一点被注册了。忘记这么做会导致任务被无限期地挂起（因为没 waker 去通知 executor 来 poll 了）。</p>
<p>忘记在返回 <code>Poll::Pending</code> 后 wake 一个 task 是一个常见的 bug 来源。</p>
</blockquote>
<p>回看一下 <code>Delay</code> 的第一次迭代。这是 future 的实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Future for Delay {
    type Output = &amp;'static str;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;&amp;'static str&gt;
    {
        if Instant::now() &gt;= self.when {
            println!(&quot;Hello world&quot;);
            Poll::Ready(&quot;done&quot;)
        } else {
            // Ignore this line for now.
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>当时被注释暂时先忽略的那一行：咱返回 <code>Poll::Pending</code> 前，我们调用了 <code>cx.waker().wake_by_ref()</code> 。这是为了满足 future 的约定。通过返回 <code>Poll::Pending</code> 我们负责向 waker 发送 wake 信号。。因为我们暂时还没有实现 timer thread，所以我们直接用 inline 的方式向 waker 发送了信号。这么做会导致这个 future 被立即再调度(re-scheduled)，再次执行，并且可能还是没有转变成 ready state 。</p>
<p>请注意，你可以更频繁的向 waker 发送信号，而不必是必须必要的时候才发送信号。在这种特殊情况下，我们向 waker 发送信号，即使我们根本还没准备好继续操作。除了会浪费一些 CPU 资源外没有任何不对的。然而这种特殊的实现将会导致一个 busy loop 。</p>
<h3 id="updating-mini-tokio"><a class="header" href="#updating-mini-tokio">Updating Mini Tokio</a></h3>
<p>接下来就是改变我们的 Mini Tokio 来接收 waker notifications 。我们希望 executor 只在它们被唤醒的时候执行任务，为了做到这点， Mini tokio 将会提供它自己的 waker 。当这个 waker 被调用，它所关联的任务就会排队来执行。Mini-Tokio 在 poll future 的时候会把它的 waker 传递给 future。</p>
<p>更新后的 Mini Tokio 将会使用一个 channel 来存储被调度的任务。channel 允许从任何线程来排队执行任务。Wakers 必须是实现了 <code>Send</code> 和 <code>Sync</code> 的，因此我们可以使用来此 <a href="https://docs.rs/crossbeam/latest/crossbeam/channel/index.html"><code>crossbeam</code></a> crate 的 channel，因为标准库的 channel 没实现 <code>Sync</code> 。</p>
<blockquote>
<p><code>Send</code> 和 <code>Sync</code> traits 是 Rust 提供的关于并发的“标记 trait“。能被 <strong>send</strong> 到不同线程的类型是 <code>Send</code> 。大多数类型都是 <code>Send</code> ，但是有些像 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> 这样的不是。类型能被通过不可变引用被<strong>并发</strong>访问的是 <code>Sync</code> 。一个类型可以是 <code>Send</code> 但不一定是 <code>Sync</code> — 一个很好的例子就是 <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> ，可以通过不可变引用来修改内容（内部可变性），因此通过并发访问是不安全的。</p>
<p>更多细节可以看  <a href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html">the Rust book 中相关的章节</a> 。</p>
</blockquote>
<p>把下面的依赖加到 <code>Cargo.toml</code> 来获取我们需要的 channel 。</p>
<pre><code class="language-toml">crossbeam = &quot;0.8&quot;
</code></pre>
<p>然后改 <code>MiniTokio</code> 结构体。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crossbeam::channel;
use std::sync::Arc;

struct MiniTokio {
    scheduled: channel::Receiver&lt;Arc&lt;Task&gt;&gt;,
    sender: channel::Sender&lt;Arc&lt;Task&gt;&gt;,
}

struct Task {
    // This will be filled in soon.
}
<span class="boring">}</span></code></pre></pre>
<p>Wakers 是 <code>Sync</code> 并且可以被 clone。当 <code>wake</code> 被调用，任务必须被调度来执行。为了实现这个目的，我们整了个 channel 。当 <code>wake()</code> 在 waker 身上被调用时，任务会被推进 channel 的 send 的那一半（channel 被拆成两半，一半 send 一半 receive）。我们的 <code>Task</code> 结构体将会实现 wake 逻辑。为了做到这点，它需要同时包含生成的任务和 channel 的 send 。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};

struct Task {
    // The `Mutex` is to make `Task` implement `Sync`. Only
    // one thread accesses `future` at any given time. The
    // `Mutex` is not required for correctness. Real Tokio
    // does not use a mutex here, but real Tokio has
    // more lines of code than can fit in a single tutorial
    // page.
    future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + Send&gt;&gt;&gt;,
    executor: channel::Sender&lt;Arc&lt;Task&gt;&gt;,
}

impl Task {
    fn schedule(self: &amp;Arc&lt;Self&gt;) {
        self.executor.send(self.clone());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>为了调度任务，<code>Arc</code> 会被 clone 然后通过 channel 发送出去。现在，我们需要将我们的 <code>schedule</code> 函数和 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>std::task::Waker</code></a> 挂钩。标注版酷提供了一个低层次 API ，通过 <a href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html">manual vtable construction</a> （手动构造 vtable，vtable 能够产生晚绑定行为，只有在运行时才知道调用的是什么函数，例如调用 vtable 中的 A，然后会把 A 映射的函数指针 *B 拿出来执行）来做这件事。这个方案为实现者提供了最大程度的灵活性，但是要求一大堆 unsafe 样板代码。与直接使用 <a href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html"><code>RawWakerVTable</code></a> 相反，我们将会使用  <a href="https://docs.rs/futures/"><code>futures</code></a> crate 提供的 <a href="https://docs.rs/futures/0.3/futures/task/trait.ArcWake.html"><code>ArcWake</code></a> trait，它允许我们通过实现一个简单的 trait 来暴露我们的 <code>Task</code> 结构体作为一个 waker 。</p>
<p>把下面的依赖加入到 <code>Cargo.toml</code>。</p>
<pre><code class="language-toml">futures = &quot;0.3&quot;
</code></pre>
<p>然后实现  <a href="https://docs.rs/futures/0.3/futures/task/trait.ArcWake.html"><code>futures::task::ArcWake</code></a> 。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::task::{self, ArcWake};
use std::sync::Arc;
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
        arc_self.schedule();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>当之前的那个 timer thread 调用 <code>waker.wake()</code> ，任务会被推进 channel 。接着我们实现一下 <code>MiniTokio::run()</code> 函数中的接收并执行任务的部分。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MiniTokio {
    fn run(&amp;self) {
        while let Ok(task) = self.scheduled.recv() {
            task.poll();
        }
    }

    /// 初始化 mini-tokio 实例
    fn new() -&gt; MiniTokio {
        let (sender, scheduled) = channel::unbounded();

        MiniTokio { scheduled, sender }
    }

    /// 生成一个 future 加到 mini-tokio 实例上
    /// 
    /// 把接收到的 future 包装进 `Task` ，`Task` 可以把自己发送到
    /// `scheduled` queue。然后里面包装的 future 就能在 mini-redis 实例的
    /// `run` 调用中被拿出来执行了。
    fn spawn&lt;F&gt;(&amp;self, future: F)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        Task::spawn(future, &amp;self.sender);
    }
}

impl Task {
    fn poll(self: Arc&lt;Self&gt;) {
        // 从 `Task` 创建一个 waker。这使用了上面我们给 `Task`
        // 实现的 `ArcWake` trait，这个 `waker` 方法就是 `ArcWake` 的，
        // 用来从实现了 `ArcWake` trait 的类型上生成一个 waker 
        let waker = task::waker(self.clone());
        let mut cx = Context::from_waker(&amp;waker);

        // No other thread ever tries to lock the future
        let mut future = self.future.try_lock().unwrap();

        // Poll the future
        let _ = future.as_mut().poll(&amp;mut cx);
    }

    // Spawns a new task with the given future.
    //
    // Initializes a new Task harness containing the given future and pushes it
    // onto `sender`. The receiver half of the channel will get the task and
    // execute it.
    fn spawn&lt;F&gt;(future: F, sender: &amp;channel::Sender&lt;Arc&lt;Task&gt;&gt;)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        let task = Arc::new(Task {
            future: Mutex::new(Box::pin(future)),
            executor: sender.clone(),
        });

        let _ = sender.send(task);
    }

}
<span class="boring">}</span></code></pre></pre>
<p>这里发生了很多事情。首先，<code>MiniTokio::run()</code> 被实现了，这个函数启动了一个 loop 从 channel 接收被调度的任务。因为任务在被唤醒的时候会被推进这个 channel，所以这些任务能够在要执行的时候顺利取得进展。</p>
<p>此外，<code>MiniTokio::new()</code> 和 <code>MiniTokio::spawn()</code> 函数被调整为使用一个 channel 而不是一个 <code>VecDeque</code> 。当新的任务产生，它们会被给到这个 channel 的 send 的 clone，使得任务可以在运行时调度自己（通过把自己塞进 send 里送到 channel 中去）。</p>
<p><code>Task::poll()</code> 函数会通过手动为  <code>Task</code> 实现的 <code>future</code> crate 中的  <a href="https://docs.rs/futures/0.3/futures/task/trait.ArcWake.html"><code>ArcWake</code></a> trait 来创建 waker 。这个 waker 被用来创建一个 <code>task::Context</code> ，然后这个 <code>task::Context</code> 被传给 <code>poll</code> 。</p>
<h2 id="summary-概括"><a class="header" href="#summary-概括">Summary （概括）</a></h2>
<p>我们现在已经看到了异步 Rust 如何工作的端到端示例。Rust 的 <code>async/await</code> 特性由 traits  支持。这就允许了第三方 crates，像 Tokio，来提供执行细节。</p>
<ul>
<li>
<p>异步 Rust 的操作是惰性的，并且需要一个调用者去 poll 它们。</p>
</li>
<li>
<p>Waker 会被传递给 futures 来把一个 future 和调用它的任务联系起来。</p>
</li>
<li>
<p>当一个资源<strong>没有</strong>准备好完成一个操作时，会返回 <code>Poll::Pending</code> 并且任务的 waker 会记录这点。</p>
</li>
<li>
<p>当资源 ready 时，任务的 waker 会发送通知。</p>
</li>
<li>
<p>executor 接收到通知并且调度任务去执行。</p>
</li>
<li>
<p>当任务再次被 poll 的时候，此时资源已经就绪了，并且任务会取得进展。</p>
</li>
</ul>
<h2 id="a-few-loose-ends-一些零散的内容放在结尾"><a class="header" href="#a-few-loose-ends-一些零散的内容放在结尾">A few loose ends （一些零散的内容放在结尾）</a></h2>
<p>回想一下，当我们之前在实现 <code>Delay</code> 这个 future 的时候，我们说过还有一些事情需要解决。Rust 的异步模型允许单个 future 在多个任务之前迁移。思考下下面的内容：</p>
<pre><pre class="playground"><code class="language-rust">use futures::future::poll_fn;
use std::future::Future;
use std::pin::Pin;

#[tokio::main]
async fn main() {
    let when = Instant::now() + Duration::from_millis(10);
    let mut delay = Some(Delay { when });

    poll_fn(move |cx| {
        let mut delay = delay.take().unwrap();
        let res = Pin::new(&amp;mut delay).poll(cx);
        assert!(res.is_pending());
        tokio::spawn(async move {
            delay.await;
        });

        Poll::Ready(())
    }).await;
}</code></pre></pre>
<p><code>poll_fn</code> 函数使用闭包创建了一个 <code>Future</code> 实例，上面的片段中创建一个 <code>Delay</code> 实例，poll 了一下它，然后把 <code>Delay</code> 实例发送到了一个新的任务中去进行 <code>.await</code> 。在这个例子里， <code>Delay::poll</code> 被<strong>不同</strong>的 <code>Waker</code> 调用了超过一次。当发生这种情况，你必须确保在 传递给了<em>最近的</em> 那次 <code>poll</code> 的 <code>Waker</code> 上的 <code>wake</code> 被调用。</p>
<p>当实现一个 future 的时候，假设每次对 <code>poll</code> 的调用<strong>可能</strong>被应用到一个不同的 <code>Waker</code>  实例是非常重要的。poll 函数必须更新任何先前记录的 waker 为最新传给它的 waker 。</p>
<p>我们先前实现的 <code>Delay</code> 在每次被 poll 的时候都会生成一个新的线程。这当然也 ok，但是如果它被 poll 的太频繁的话就会变得非常低效。（e.g. 如果你对这个 future 和其它 future 使用了 <code>select!</code> ，那么不论他俩哪个发生了事件，两者都会被调用）。一种方法是记住你是否已经创建过一个线程，并且只在你没有创建过时去生成一个新线程。然而，如果你这么做了，你必须确保线程的 <code>Waker</code> 被更新为最近的一次 poll 的 <code>Waker</code> ，因为你不这么做的话就无法唤醒最近的那个 <code>Waker</code> 。</p>
<p>为了修复前面的那个实现，我们可以像这样做：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, Waker};
use std::thread;
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
    // 当我们已经生成了一个线程时这里是 Some，否则是 None。
    waker: Option&lt;Arc&lt;Mutex&lt;Waker&gt;&gt;&gt;,
}

impl Future for Delay {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        // 首先，如果这是 future 第一次被调用，那就生成一个 timer thread。
        // 如果 timer thread 已经在运行了，确保存储的 `Waker` 匹配当前任务的 waker。
        if let Some(waker) = &amp;self.waker {
            let mut waker = waker.lock().unwrap();

            // 检查存储的 waker 是否匹配当前任务的 waker。
            // 当 `Delay` future 在可能会被移动到不同的任务 `poll` 时，
            // 这是很有必要的。如果这种情况发生了，`Context` 中包含的 waker 会不一样
            // 并且我们必须更新我们在 `Delay` 存储的 waker 来应对变化。
            if !waker.will_wake(cx.waker()) {
                *waker = cx.waker().clone();
            }
        } else {
            let when = self.when;
            let waker = Arc::new(Mutex::new(cx.waker().clone()));
            self.waker = Some(waker.clone());

            // 这是第一次调用 `poll` 的情况，生成一个 timer thread。
            thread::spawn(move || {
                let now = Instant::now();

                if now &lt; when {
                    thread::sleep(when - now);
                }

                // The duration has elapsed. Notify the caller by invoking
                // the waker.
                let waker = waker.lock().unwrap();
                waker.wake_by_ref();
            });
        }

        // 一旦 waker 被存储了，并且 timer thread 开始了，就到了检查
        // delay 是否完成的时候了。这通过检查当前的 instant 来做到。
        // 如果时间到了，那么就意味着 future 已经完成，并且得返回 `Poll::Ready`
        if Instant::now() &gt;= self.when {
            Poll::Ready(())
        } else {
            // 时间还没到，future 还没完成，返回 `Poll::Pending`。
            //
            // `Future` trait 约定了：当 `Pending` 被返回时，future 确保
            // 一旦再次被 poll 就会往给定的 waker 发送信号。在我们的情况下，
            // 通过在这返回 `Pending`，我们承诺一旦请求的时间过了，我们将会调用包含在 `Context`
            // 参数内的 waker。我们通过在上面生成一个 timer thread 来确保这点。
            //
            // 如果我们忘记调用 waker，这个任务将会无期限的挂起。
            Poll::Pending
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这有一点复杂，但是我们的想法是，对每个 <code>poll</code> 的调用，future 都会检查当前 <code>poll</code> 给的 waker 跟之前记录的 waker 是不是匹配的。如果两个 waker 匹配，那么就不会做其它的事情了。如果它们不匹配，那么就记录最新的 <code>poll</code> 里的 waker。</p>
<h3 id="notify-utility"><a class="header" href="#notify-utility"><code>Notify</code> utility</a></h3>
<p>我们演示了如果使用 waker 来手动实现 <code>Delay</code> future。Wakers 是异步 Rust 如何去工作的基础。通常，没有必要去降低到那样的 level（手动实现 future 是一种偏向底层的行为）。举个例子，在这个 <code>Delay</code> 的场景，我们可以通过使用 <a href="https://docs.rs/tokio/1/tokio/sync/struct.Notify.html"><code>tokio::sync::Notify</code></a> 实用工具纯使用 <code>async/await</code> 来实现它。这个实用工具提供了一个基本的任务通知机制，它会处理 waker 的细节，包括确保记录的 waker 匹配当前的 task 。</p>
<p>使用 <a href="https://docs.rs/tokio/1/tokio/sync/struct.Notify.html"><code>Notify</code></a> ，我们可以像这样使用 <code>await</code> 实现一个 <code>delay</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::Notify;
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::thread;

async fn delay(dur: Duration) {
    let when = Instant::now() + dur;
    let notify = Arc::new(Notify::new());
    let notify2 = notify.clone();

    thread::spawn(move || {
        let now = Instant::now();

        if now &lt; when {
            thread::sleep(when - now);
        }

        notify2.notify_one();
    });


    notify.notified().await;
}
<span class="boring">}</span></code></pre></pre>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../rust/mini-redis/framing.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../rust/mini-redis/select.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../rust/mini-redis/framing.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../../rust/mini-redis/select.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script type="text/javascript">
        window.playground_copyable = true;
    </script>


    <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "rust/mini-redis/async_in_depth.md"
    </script>


    <!-- Custom JS scripts -->
    <script type="text/javascript" src="../../assets/custom.js"></script>
    <script type="text/javascript" src="../../assets/bigPicture.js"></script>


</body>

</html>