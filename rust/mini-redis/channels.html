<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Channels - M4n5ter Blog</title>


    <!-- Custom HTML head -->
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../../theme/style3.css">

</head>

<body class="sidebar-visible no-js">
    <div id="body-container"></div>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "../../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script>
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('light')
        html.classList.add(theme);
        var body = document.querySelector('body');
        body.classList.remove('no-js')
        body.classList.add('js');
    </script>

    <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">
    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var body = document.querySelector('body');
        var sidebar = null;
        var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        } else {
            sidebar = 'hidden';
        }
        sidebar_toggle.checked = sidebar === 'visible';
        body.classList.remove('sidebar-visible');
        body.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="../../intro/intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="../../go/go.html"><strong aria-hidden="true">2.</strong> GO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../go/gin_zo.html"><strong aria-hidden="true">2.1.</strong> Gin + ZincObserve</a></li><li class="chapter-item "><a href="../../go/pstash.html"><strong aria-hidden="true">2.2.</strong> pstash(My Project)</a></li></ol></li><li class="chapter-item expanded "><a href="../../rust/rust.html"><strong aria-hidden="true">3.</strong> RUST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tower/rust_tower.html"><strong aria-hidden="true">3.1.</strong> Tower</a></li><li class="chapter-item expanded "><a href="../../rust/mini-redis/mini-redis.html"><strong aria-hidden="true">3.2.</strong> mini-redis</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/mini-redis/hello_tokio.html"><strong aria-hidden="true">3.2.1.</strong> Hello Tokio</a></li><li class="chapter-item "><a href="../../rust/mini-redis/spawning.html"><strong aria-hidden="true">3.2.2.</strong> Spawning</a></li><li class="chapter-item "><a href="../../rust/mini-redis/shared_state.html"><strong aria-hidden="true">3.2.3.</strong> Shared state</a></li><li class="chapter-item expanded "><a href="../../rust/mini-redis/channels.html" class="active"><strong aria-hidden="true">3.2.4.</strong> Channels</a></li><li class="chapter-item "><a href="../../rust/mini-redis/io.html"><strong aria-hidden="true">3.2.5.</strong> I/O</a></li><li class="chapter-item "><a href="../../rust/mini-redis/framing.html"><strong aria-hidden="true">3.2.6.</strong> Framing</a></li><li class="chapter-item "><a href="../../rust/mini-redis/async_in_depth.html"><strong aria-hidden="true">3.2.7.</strong> Async in depth</a></li><li class="chapter-item "><a href="../../rust/mini-redis/select.html"><strong aria-hidden="true">3.2.8.</strong> Select</a></li><li class="chapter-item "><a href="../../rust/mini-redis/streams.html"><strong aria-hidden="true">3.2.9.</strong> Streams</a></li></ol></li><li class="chapter-item "><a href="../../rust/tokio/tokio.html"><strong aria-hidden="true">3.3.</strong> Tokio</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tokio/topics.html"><strong aria-hidden="true">3.3.1.</strong> Topics TODO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../rust/tokio/bridging_with_sync_code.html"><strong aria-hidden="true">3.3.1.1.</strong> Bridging with sync code TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/graceful_shutdown.html"><strong aria-hidden="true">3.3.1.2.</strong> Graceful Shutdown TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/getting_started_with_tracing.html"><strong aria-hidden="true">3.3.1.3.</strong> Getting started with Tracing TODO</a></li><li class="chapter-item "><a href="../../rust/tokio/next_steps_with_tracing.html"><strong aria-hidden="true">3.3.1.4.</strong> Next steps with Tracing TODO</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../other-categories/other-categories.html"><strong aria-hidden="true">4.</strong> Other categories</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../other-categories/archlinux/archlinux.html"><strong aria-hidden="true">4.1.</strong> archlinux</a></li><li class="chapter-item "><a href="../../other-categories/algorithm/algorithm.html"><strong aria-hidden="true">4.2.</strong> algorithm</a></li><li class="chapter-item "><a href="../../other-categories/nc/nc.html"><strong aria-hidden="true">4.3.</strong> nmap-netcat(nc)</a></li><li class="chapter-item "><a href="../../other-categories/mkcert/mkcert.html"><strong aria-hidden="true">4.4.</strong> mkcert</a></li><li class="chapter-item "><a href="../../other-categories/aria2/aria2.html"><strong aria-hidden="true">4.5.</strong> aria2</a></li><li class="chapter-item "><a href="../../other-categories/postgres/postgres.html"><strong aria-hidden="true">4.6.</strong> postgres</a></li><li class="chapter-item "><a href="../../other-categories/pre-commit/pre-commit.html"><strong aria-hidden="true">4.7.</strong> pre-commit</a></li><li class="chapter-item "><a href="../../other-categories/minio/minio.html"><strong aria-hidden="true">4.8.</strong> minio</a></li><li class="chapter-item "><a href="../../other-categories/git/git.html"><strong aria-hidden="true">4.9.</strong> git</a></li><li class="chapter-item "><a href="../../other-categories/croc/croc.html"><strong aria-hidden="true">4.10.</strong> croc</a></li><li class="chapter-item "><a href="../../other-categories/reality/reality.html"><strong aria-hidden="true">4.11.</strong> REALITY</a></li></ol></li><li class="chapter-item expanded "><a href="../../blockchain/blockchain.html"><strong aria-hidden="true">5.</strong> Blockchain</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../blockchain/fundamentals.html"><strong aria-hidden="true">5.1.</strong> fundamentals</a></li><li class="chapter-item "><a href="../../blockchain/substrate/substrate.html"><strong aria-hidden="true">5.2.</strong> substrate TODO</a></li></ol></li><li class="chapter-item expanded "><a href="../../issues/issues.html"><strong aria-hidden="true">6.</strong> issues and solutions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../isuues/linux/linux_issues.html"><strong aria-hidden="true">6.1.</strong> linux</a></li><li class="chapter-item "><a href="../../issues/docker/docker_issues.html"><strong aria-hidden="true">6.2.</strong> docker</a></li><li class="chapter-item "><a href="../../issues/mysql/mysql_issues.html"><strong aria-hidden="true">6.3.</strong> mysql</a></li><li class="chapter-item "><a href="../../issues/gitea/gitea_issues.html"><strong aria-hidden="true">6.4.</strong> gitea</a></li><li class="chapter-item "><a href="../../issues/nginx/nginx_issues.html"><strong aria-hidden="true">6.5.</strong> nginx</a></li></ol></li><li class="chapter-item expanded "><a href="../../links/links.html"><strong aria-hidden="true">7.</strong> Links</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle">
            <div class="sidebar-resize-indicator"></div>
        </div>
    </nav>

    <!-- Track and set sidebar scroll position -->
    <script>
        var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
        sidebarScrollbox.addEventListener('click', function (e) {
            if (e.target.tagName === 'A') {
                sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
            }
        }, { passive: true });
        var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
        sessionStorage.removeItem('sidebar-scroll');
        if (sidebarScrollTop) {
            // preserve sidebar scroll position when navigating via links within sidebar
            sidebarScrollbox.scrollTop = sidebarScrollTop;
        } else {
            // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
            var activeSection = document.querySelector('#sidebar .active');
            if (activeSection) {
                activeSection.scrollIntoView({ block: 'center' });
            }
        }
    </script>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky">
                <div class="left-buttons">
                    <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                        title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </label>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">M4n5ter Blog</h1>

                <div class="right-buttons">
                    <a href="../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/m4n5ter/m4n5ter.github.io" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    <a href="https://github.com/m4n5ter/m4n5ter.github.io/edit/main/src/rust/mini-redis/channels.md" title="Suggest an edit" aria-label="Suggest an edit">
                        <i id="git-edit-button" class="fa fa-edit"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script>
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>现在我们已经了解了一些关于 Tokio 的并发，让我们把它们应用到客户端侧吧。把我们先前写的服务端的代码移动到一个显式的二进制文件里去：</p>
<pre><code class="language-zsh">mkdir src/bin
mv src/main.rs src/bin/server.rs
</code></pre>
<p>然后创建一个新的 binary 来放我们的客户端代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>touch src/bin/client.rs
<span class="boring">}</span></code></pre></pre>
<p>在这个文件中，我们将会写关于本节的代码。无论何时你想运行它，请先启动 server 端：</p>
<pre><code class="language-zsh">cargo run --bin server
</code></pre>
<p>然后在另一个终端窗口：</p>
<pre><code class="language-zsh">cargo run --bin client
</code></pre>
<p>话都说到这个份上了，来让我们开始 code 吧！</p>
<p>比如说我门想要运行两个并发的 Redis commands。我们可以为每个 command 生成一个任务。然后两个命令就能并发啦～</p>
<p>一开始啊，我们可能会想到下面这种方式：</p>
<pre><pre class="playground"><code class="language-rust">use mini_redis::client;

#[tokio::main]
async fn main() {
    // Establish a connection to the server
    let mut client = client::connect("127.0.0.1:6379").await.unwrap();

    // Spawn two tasks, one gets a key, the other sets a key
    let t1 = tokio::spawn(async {
        let res = client.get("hello").await;
    });

    let t2 = tokio::spawn(async {
        client.set("foo", "bar".into()).await;
    });

    t1.await.unwrap();
    t2.await.unwrap();
}</code></pre></pre>
<p>不幸的是呢，编译器阻止了我们继续，因为两个任务都需要用某种方式访问 <code>client</code> 。由于</p>
<p><code>Client</code> 并没有实现 <code>Copy</code> trait ，所以如果没有一些代码来促成 <code>client</code> 的共享是不能被编译通过的。再说，<code>Client::set</code> 需要 <code>&amp;mut self</code> ，这意味着调用它的时候需要独占 <code>Client</code> 的访问。我们可以为每个连接打开一个任务，但是这并不理想。因为 <code>.await</code> 需要带着锁被调用，所以我们不能使用 <code>std::sync::Mutex</code> 。我们可以使用 <code>tokio::sync::Mutex</code> ，但是这会导致同一时间只能有一个请求（即 singleflight 单飞）。如果客户端实现了 <a href="https://redis.io/topics/pipelining">pipelining</a> ，一个异步锁会导致连接的低利用率。</p>
<h2 id="message-passing-消息传递"><a class="header" href="#message-passing-消息传递">Message passing （消息传递）</a></h2>
<p>实践答案是使用消息传递！这种模式包含生成一个专门的任务来管理 <code>client</code> 资源。任何想要发起请求的任务都要发送消息给这个 <code>client</code> 任务。<code>client</code> 任务的角色相当于代理人，它会代表发送者(sender)来发送请求(request)，并把响应(response)发回给发送者(sender)。</p>
<p>采用这种策略，需要创建一个单独的连接。管理 <code>client</code> 的任务能够独占访问权限以便调用 <code>set</code> 和 <code>get</code> 。此外， channel 以缓冲区的方式工作。当 <code>client</code> 任务正忙的时候，任务可能会被发送到 <code>client</code> 。一旦 <code>client</code> 空闲了，可以处理新请求了，它会从 channel 拉去下一个请求。这种方式可以有更好的吞吐量，并且能够被拓展，支持连接池。</p>
<h2 id="tokios-channel-primitives-tokio-的通道原语"><a class="header" href="#tokios-channel-primitives-tokio-的通道原语">Tokio's channel primitives （Tokio 的通道原语）</a></h2>
<p>Tokio 提供了 <a href="https://docs.rs/tokio/1/tokio/sync/index.html">一些 channel</a> ，每个都有不一样的目的。</p>
<ul>
<li>
<p><a href="https://docs.rs/tokio/1/tokio/sync/mpsc/index.html">mpsc</a>：多生产者，单消费者的 channel。可以发送许多值。</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/1/tokio/sync/oneshot/index.html">oneshot</a>：单生产者，单消费者的 channel。可以发送单个值。</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/1/tokio/sync/broadcast/index.html">broadcast</a>：多生产者，多消费者。可以发送许多值，每个接收者都能看到每个值。</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/1/tokio/sync/watch/index.html">watch</a>：单生产者，多消费者。可以发送许多值，但是不会保留历史值。接收者只能看到最新的值。</p>
</li>
</ul>
<p>如果你需要一个多生产者多消费者的 channel，其中每条消息只能由所有现有消费者中的一个接收，那么你可以使用  <a href="https://docs.rs/async-channel/"><code>async-channel</code></a> crate。异步 Rust 之外还有同步的 channel，比如 <a href="https://doc.rust-lang.org/stable/std/sync/mpsc/index.html"><code>std::sync::mpsc</code></a> 和 <a href="https://docs.rs/crossbeam/latest/crossbeam/channel/index.html"><code>crossbeam::channel</code></a>。这些 channel 都会在等待消息的时候阻塞线程，这意味着它们不适合用在异步代码中。</p>
<p>在这块内容里，我们会使用 <a href="https://docs.rs/tokio/1/tokio/sync/mpsc/index.html">mpsc</a> 和 <a href="https://docs.rs/tokio/1/tokio/sync/oneshot/index.html">oneshot</a> 。其他类型的 channel 会在之后的内容中探索。本节内容的完整代码在<a href="https://github.com/tokio-rs/website/blob/master/tutorial-code/channels/src/main.rs">这里</a> 。</p>
<h2 id="define-the-message-type-定义消息类型"><a class="header" href="#define-the-message-type-定义消息类型">Define the message type （定义消息类型）</a></h2>
<p>在许多使用消息传递的场景下，接收消息的任务会响应多条命令。在我们的场景下，任务将会响应 <code>GET</code> 和 <code>SET</code> 命令。为了模拟这个，我们先定义一个 <code>Command</code> enum 。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::Bytes;

#[derive(Debug)]
enum Command {
    Get {
        key: String,
    },
    Set {
        key: String,
        val: Bytes,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="create-the-channel-创建通道"><a class="header" href="#create-the-channel-创建通道">Create the channel （创建通道）</a></h2>
<p>在 <code>main</code> 函数中，我们创建一个 <code>mpsc</code> channel。</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    // 创建一个新的 mpsc ，并给它的最大容量设置为 32。
    let (tx, mut rx) = mpsc::channel(32);

    // ... Rest comes here
}</code></pre></pre>
<p><code>mpsc</code> 用来<strong>发送</strong>命令给管理 redis connection 的任务。多生产者的容量允许消息可以从多个任务中发送。创建 channel 会返回两个值，一个 sender（习惯上命名为 <code>tx</code>） 和一个 receiver （习惯上命名为 <code>rx</code>）。这俩句柄是分开使用的，它们可能会被移动到不同的任务中去。</p>
<p>这里的 channel 创建时指定了 32 个容量。如果消息发的比收的快，那么 channel 会把没来得及被接收的消息存起来。一旦 channel 中的 32 个位置都被消息填满了，这时候再调用 <code>send(...).await</code> 将会 sleep 直到有 1 个消息被 receiver 拿走去消费。</p>
<p>从多个任务发送消息是通过 clone <code>Sender</code> 做到的。例如：</p>
<pre><pre class="playground"><code class="language-rust">use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);
    let tx2 = tx.clone();

    tokio::spawn(async move {
        tx.send("sending from first handle").await;
    });

    tokio::spawn(async move {
        tx2.send("sending from second handle").await;
    });

    while let Some(message) = rx.recv().await {
        println!("GOT = {}", message);
    }
}</code></pre></pre>
<p>两条消息都被发送到了单个 <code>Receiver</code> 句柄。在 <code>mpsc</code> channel 中克隆 receiver 是不被允许的。</p>
<p>当每个 <code>Sender</code> 超出作用域或者因为其他原因被 drop 了，就不再能往这个 channel 发送更多消息了。此时，在 <code>Receiver</code> 上调用 <code>recv</code> 将会返回 <code>None</code>，这意味着所有的 sender 都不在了，channel 被关闭了。</p>
<p>在我们的场景下，管理 redis connection 的任务知道一旦 channel 被关闭，就得关闭 redis connection，因为 connection 不会再被使用了。</p>
<h2 id="spawn-manager-task-生成管理者任务"><a class="header" href="#spawn-manager-task-生成管理者任务">Spawn manager task （生成管理者任务）</a></h2>
<p>接下来，生成一个任务来处理来自 channel 的消息。首先，一个对 redis 的客户端连接会被建立。然后，受到的命令会通过 redis connection 被发送。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mini_redis::client;
// The `move` keyword is used to **move** ownership of `rx` into the task.
let manager = tokio::spawn(async move {
    // Establish a connection to the server
    let mut client = client::connect("127.0.0.1:6379").await.unwrap();

    // Start receiving messages
    while let Some(cmd) = rx.recv().await {
        use Command::*;

        match cmd {
            Get { key } =&gt; {
                client.get(&amp;key).await;
            }
            Set { key, val } =&gt; {
                client.set(&amp;key, val).await;
            }
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<p>现在，更新这两个任务以通过通道发送命令，而不是直接在Redis连接上发出它们。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The `Sender` handles are moved into the tasks. As there are two
// tasks, we need a second `Sender`.
let tx2 = tx.clone();

// Spawn two tasks, one gets a key, the other sets a key
let t1 = tokio::spawn(async move {
    let cmd = Command::Get {
        key: "hello".to_string(),
    };

    tx.send(cmd).await.unwrap();
});

let t2 = tokio::spawn(async move {
    let cmd = Command::Set {
        key: "foo".to_string(),
        val: "bar".into(),
    };

    tx2.send(cmd).await.unwrap();
});
<span class="boring">}</span></code></pre></pre>
<p>在 <code>main</code> 函数的底部，我们 <code>.await</code> 这些 <a href="https://docs.rs/tokio/latest/tokio/task/struct.JoinHandle.html"><code>JoinHandle</code></a> 来确保commands 能够在进程退出前完全完成。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>t1.await.unwrap();
t2.await.unwrap();
manager.await.unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="receive-responses-接收响应"><a class="header" href="#receive-responses-接收响应">Receive responses （接收响应）</a></h2>
<p>最后一步是从管理器任务接收响应(response)。<code>GET</code> command 需要获取 value 并且 <code>SET</code> command 需要知道它的操作是否成功完成。</p>
<p>为了传递响应，我们使用一个 <code>oneshot</code> channel。<code>oneshot</code> channel 是一个单生产者，单消费者的 channel，针对发送单一值进行了优化。在我们的场景下，响应就是单一值。</p>
<p>与 <code>mpsc</code> 类似，<code>oneshot::channel()</code> 返回一个 sender 和一个 receiver 句柄。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::oneshot;

let (tx, rx) = oneshot::channel();
<span class="boring">}</span></code></pre></pre>
<p>不像 <code>mpsc</code> ，<code>oneshot</code> 不需要指定容量，因为它的容量始终是 1。另外，<code>oneshot</code> 的两个句柄都不能被 clone。</p>
<p>为了从管理器任务接收响应，在发送一个 command 之前，要先创建一个 <code>oneshot</code> channel。<code>oneshot</code> 的 <code>Sender</code> 会被包含在发给管理器任务中的 command 中。而 <code>Receiver</code> 用来接收管理器任务用 <code>oneshot</code> 的 <code>Sender</code> 发送的消息。</p>
<p>首先，改变 <code>Command</code> 来包含 <code>Sender</code> 。方便起见，用了一个类型别名来使用 <code>Sender</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::oneshot;
use bytes::Bytes;

/// Multiple different commands are multiplexed over a single channel.
#[derive(Debug)]
enum Command {
    Get {
        key: String,
        resp: Responder&lt;Option&lt;Bytes&gt;&gt;,
    },
    Set {
        key: String,
        val: Bytes,
        resp: Responder&lt;()&gt;,
    },
}

/// Provided by the requester and used by the manager task to send
/// the command response back to the requester.
type Responder&lt;T&gt; = oneshot::Sender&lt;mini_redis::Result&lt;T&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p>现在，改变发送 command 的任务，让它包含一个 <code>oneshot::Sender</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let t1 = tokio::spawn(async move {
    let (resp_tx, resp_rx) = oneshot::channel();
    let cmd = Command::Get {
        key: "hello".to_string(),
        resp: resp_tx,
    };

    // Send the GET request
    tx.send(cmd).await.unwrap();

    // Await the response
    let res = resp_rx.await;
    println!("GOT = {:?}", res);
});

let t2 = tokio::spawn(async move {
    let (resp_tx, resp_rx) = oneshot::channel();
    let cmd = Command::Set {
        key: "foo".to_string(),
        val: "bar".into(),
        resp: resp_tx,
    };

    // Send the SET request
    tx2.send(cmd).await.unwrap();

    // Await the response
    let res = resp_rx.await;
    println!("GOT = {:?}", res);
});
<span class="boring">}</span></code></pre></pre>
<p>在 <code>oneshot::Sender</code> 上的 <code>send</code> 调用是立即完成的，<strong>不需要</strong>一个 <code>.await</code> 。这是因为 <code>oneshot</code> channel 上的 <code>send</code> 总是立即返回 succeed 或者 fail ，而不需要任何形式的等待。</p>
<p>当接收端被 drop 时，往一个 oneshot channel 发送一个值会返回 <code>Err</code> 。这表示接收端不再对结果感兴趣了。在我们的假设中，接收端(想发命令的任务)不再对 response(管理器任务返回的结果) 感兴趣的情况是可接受的。所以通过 <code>resp.send(...)</code>  返回的 <code>Err</code>  就没必要处理了。</p>
<p>可以在<a href="https://github.com/tokio-rs/website/blob/master/tutorial-code/channels/src/main.rs">这里</a>看到完整代码。</p>
<h2 id="backpressure-and-bounded-channels-背压和有界的通道"><a class="header" href="#backpressure-and-bounded-channels-背压和有界的通道">Backpressure and bounded channels (背压和有界的通道)</a></h2>
<p>这里的小标题我不会翻译 :(</p>
<p>每当引入并发(cibcurrency)和队列(queuing)的时候，确保队列有界且系统能优雅的处理负载是非常重要的。无界的队列将会导致可用内存耗尽，并且还会导致系统陷入无法预测的失败中。</p>
<p>Tokio 会注意避免隐式队列。事实上很大一部分是因为异步操作是惰性的（这在前面提到过，这也是 rust 与其它实现 <code>async/await</code> 的语言的不同之处）。思考下下面的情况：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    async_op();
}
<span class="boring">}</span></code></pre></pre>
<p>如果异步操作迫切的希望被运行，loop 循环在没有确保先前的操作完成的情况下，反复将新的 <code>async_op</code> 排进一个队列来运行，这会导致隐式的无界队列。基于回调（callback）和基于勤奋 future（rust 是惰性 future）的系统会特别容易受到这种影响。</p>
<p>然而~，使用 Tokio 和异步 Rust ，上述片段根本就不会被运行。这是因为 <code>.await</code> 从未被调用。如果上述片段改成使用 <code>.await</code> ，那么这个循环就会在重新开始之前等待操作执行完毕。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    // 在 `async_op` 完成之前是不会重新开始循环的
    async_op().await;
}
<span class="boring">}</span></code></pre></pre>
<p>并发和队列必须被显式地引入。这么做的方法包括：</p>
<ul>
<li>
<p><code>tokio::spawn</code></p>
</li>
<li>
<p><code>select!</code></p>
</li>
<li>
<p><code>join!</code></p>
</li>
<li>
<p><code>mpsc::channel</code></p>
</li>
</ul>
<p>当需要这么做的时候，请确保并发的总量是有界的（不要无限制的创建 task）。举个例子，当写一个 TCP accept loop 的时候，确保打开的 socket 总数是有界的。当使用 <code>mpsc::channel</code>时，选择一个能够被管理的容量限度（容量不要超出实际承受能力）。指定有界值是特定于应用的。</p>
<p>小心和选择好的界限是编写可靠的Tokio应用程序的重要组成部分。</p>

                    <!-- 暂时关闭评论 -->
                    <!--<div id="giscus-container"></div>-->
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../rust/mini-redis/shared_state.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../rust/mini-redis/io.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../rust/mini-redis/shared_state.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next prefetch" href="../../rust/mini-redis/io.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>




    <script>
        window.playground_copyable = true;
    </script>


    <script src="../../elasticlunr.min.js"></script>
    <script src="../../mark.min.js"></script>
    <script src="../../searcher.js"></script>

    <script src="../../clipboard.min.js"></script>
    <script src="../../highlight.js"></script>
    <script src="../../book.js"></script>

    <script type="text/javascript" charset="utf-8">
        var pagePath = "rust/mini-redis/channels.md"
    </script>


    <!-- Custom JS scripts -->
    <script src="../../assets/custom.js"></script>
    <script src="../../assets/bigPicture.js"></script>


</body>

</html>