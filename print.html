<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>M4n5ter Blog</title>
    <meta name="robots" content="noindex" />
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="theme/style3.css">
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');
            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }
            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="intro/intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="rust/rust.html"><strong aria-hidden="true">2.</strong> RUST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rust/rust_tower.html"><strong aria-hidden="true">2.1.</strong> Tower</a></li></ol></li><li class="chapter-item expanded "><a href="math/math.html"><strong aria-hidden="true">3.</strong> Math</a></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">M4n5ter Blog</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/m4n5ter/m4n5ter.github.io" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                // Get viewed page store
                var viewed_key = 'mdbook-viewed';
                var viewed_map = {};
                try {
                    var viewed_storage = localStorage.getItem(viewed_key);
                    if (viewed_storage) {
                        viewed_map = JSON.parse(viewed_storage)
                    }
                } catch (e) { }

                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);

                    // Apply viewed style
                    if (viewed_map[link.pathname]) {
                        link.classList.add('md-viewed')
                    }
                });

                // Mark viewed after 30s
                setTimeout(function () {
                    viewed_map[location.pathname] = 1;
                    localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                }, 30000)
            </script>

            <div id="content" class="content">
                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>这是 <a href="https://github.com/m4n5ter">M4n5ter</a> 的博客</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h3 id="简介"><a class="header" href="#简介">简介</a></h3>
<p>Tower 是一个专注于对网络编程进行抽象的框架，将网络编程中的各行为进行抽象从而提高代码复用率。</p>
<p>Tower 最核心的抽象为 Service trait，其接受一个 request 进行处理，成功则返回 response，否则返回 error。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn(Request) -&gt; Result&lt;Response, Error&gt;
<span class="boring">}
</span></code></pre></pre>
<p>这个抽象可以同时运用于客户端和服务端。同时 Tower 也提供了 超时处理、访问频率限制和负载均衡之类的组件，这些功能可以被抽象为在 inner Service 调用之前和之后进行一些操作所共同组成的Service。这些 Service 称为中间件(middleware)。</p>
<p>Tower 库对 Service 的设计希望满足以下目标：</p>
<ol>
<li>能够满足异步编程的规范</li>
<li>不同的 Service 能够灵活地层层嵌套</li>
<li>我们在给一个 Service 递交 request 时，希望能够得到该 Service 的执行情况；如果该 Service 负载过重，则需要延缓提交 request 甚至直接丢弃 request，这一点类似于 Future 中的 poll 方法。</li>
</ol>
<p>针对第一点，当 call 一个 Service 时，会直接返回一个 Future，由调用者决定怎么安排这个 Future，而不是要求实现了 Service trait 的结构体同时也实现 Future。</p>
<p>针对第二点，每个实现了 Service 的结构体自身可以继续携带一个 Service，只需要将 request 递交给里层的 Service，就实现了 Service 的嵌套，这样本结构体就成为了一个中间件。</p>
<p>针对第三点，在 Service 中定义了 <code>poll_ready</code> 方法用于获取一个 Service 的执行情况。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Service&lt;Request&gt; {
  type Response;
  type Error;
  type Future: Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;;

  fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result(), Self::Error&gt;&gt;;

  fn call(&amp;mut self, req: Request) -&gt; Self::Future;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="通过-service-trait-实现-timeout-中间件"><a class="header" href="#通过-service-trait-实现-timeout-中间件"><strong>通过 Service trait 实现 Timeout 中间件</strong></a></h3>
<p>Timout 中间件用于对某个 request 的处理限定时间，如果超过时限还没有返回，则直接返回错误。Timout 应该有个用于进一步处理的里层serivce和一个时限。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Timeout&lt;T&gt; {
  service: T,
  duration: std::time::Duration
}
<span class="boring">}
</span></code></pre></pre>
<p>将 Timeout 也定义为一个 Service</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S, Request&gt; Service&lt;Request&gt; for Timeout&lt;S&gt; 
where
  S: Service&lt;R&gt;,
  S::Error: Into&lt;Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; 
<span class="boring">}
</span></code></pre></pre>
<p><code>poll_ready</code> 非常好处理，直接将调用里层 Service 的 poll_ready 函数。</p>
<p>而 <code>call</code> 则要求返回一个 Future，如果要实现 Timeout 对应的行为逻辑，需要创建一个新的实现了 Future 的类型——ResponseFuture。我们希望它被poll时，首先会查看里层 Service 是否返回，如果已返回则返回结果，如果没有则检查是否已经timeout，如果没有则返回 Pending，如果已经超时则返回超时错误。</p>
<p>因此我们创建了一个融合了里层 future 和超时 future 的类型</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pin_project]
struct ResponseFuture&lt;F&gt; {
  #[pin]
  response_future: F,
  #[pin]
  sleep: tokio::time::Sleep
}
<span class="boring">}
</span></code></pre></pre>
<p>pin_project 可以使得 Pin 类型的字段也是 Pin 类型，在调用 poll 函数时需要用到。</p>
<p>然后为 ResponseFuture 实现 Future trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;F, Response, Error&gt; Future for ResponseFuture&lt;F&gt; 
where
    F: Future&lt;Output = Result&lt;Response, Error&gt;&gt;,
    Error: Into&lt;Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;
{
    type Output = Result&lt;Response, Box&lt;dyn std::error::Error + Sync + Send&gt;&gt;;
    fn poll(self: std::pin::Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let this = self.project();
​
        match this.response_future.poll(cx) {
            Poll::Ready(res) =&gt; {
                let result = res.map_err(Into::into);
                return Poll::Ready(result);
            },
            Poll::Pending =&gt; {}
        }
​
        match this.sleep.poll(cx) {
            Poll::Ready(_) =&gt; {
                let error = Box::new(TimeoutError(()));
                Poll::Ready(Err(error))
            },
            Poll::Pending =&gt; Poll::Pending
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="balance-中间件"><a class="header" href="#balance-中间件">Balance 中间件</a></h3>
<p>从名字就可以看出来，Balance 模块用于提供负载均衡的服务，负载均衡会根据所有服务的负载程度来决定处理 request 的服务。</p>
<p>在官方文档提供了两种 Balance 服务</p>
<ul>
<li>p2c：根据p2c算法 (Power of Two Random Choices) 实现，提供一种简单而大概的 service 选择方法，一般在无法精确每个 service 的负载时使用。</li>
<li>pool：实现了一个动态大小的服务池 (service pool)，通过追踪每个 service 的 <code>poll_ready</code> 成功的次数来估计每个 service 的负载状况。（虽然这个模块还存在于官方文档之上，但是已经从最近的源码上移除了，显然官方打算移除这个模块，参见<a href="https://github.com/tower-rs/tower/pull/658">#658</a>。</li>
</ul>
<p>这里选择p2c算法进行分析。p2c 并非是一种挑选最优的算法，而是一种避免选到最坏的算法。其随机从所有 service 中选取两个，比较两个 service 的负载，选择较小的那个 service，从而保证避免选到负载最重的 service。这个算法在 nginx 中就有所运用。</p>
<p>Balance 内部通过 ready_cache 模块维护一个 Pending 队列和一个 Ready map，当 Service 陷入 Pending 状态时，则加入 Pending 队列中，新加入的 Service 一开始也是加入到 Pending 队列中。可以通过调用 <code>promote_pending_to_ready</code> 函数遍历所有的 Pending Service 将已经 Ready 的 Service 加入到 Ready map 中。</p>
<p>同样，Balance 也实现了 Service trait：</p>
<ul>
<li><code>poll_ready</code>：只有有存在一个被选中的 Service 是ready的，那么就可以返回 ready，并记录该 Service 的 index</li>
<li><code>call</code>：直接调用上面的 index 对应的 Service 处理 request，这也就是为什么 Tower 建议在调用某个 Service 之前一定要调用 <code>poll_ready</code> 询问服务是否空闲。对应的 Service 在被调用之后会被插入到 Pending 队列中。</li>
</ul>
<p>综上所述，Balance 模块提供了一种 Service 集托管服务，通过将 Service 集托管到 Balance 模块，由 Balance 决定 request 交给哪个 Service 处理。</p>
<h3 id="buffer-中间件"><a class="header" href="#buffer-中间件">Buffer 中间件</a></h3>
<p>Buffer 中间件希望提供一个类似于 mpsc 一样多生产者单消费者一样的缓存队列，可以允许多个用户同时像某个 Service 提交 request，更重要的是，Service 要能够将 request 的执行结果返回给用户。</p>
<p>Buffer 中间件的做法是将 Service 看作一个生产者，另外定义一个 Worker 作为消费者，Worker 负责接收 request 并处理。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Worker&lt;T, Request&gt;
where T: Service&lt;Request&gt; 
{
  current_message: Option&lt;Message&lt;Request, T::Future&gt;&gt;,
  rx: mpsc::Receiver&lt;Message&lt;Request, T::Future&gt;&gt;,
  service: T,
  finish: bool,
  failed: Option&lt;ServiceError&gt;,
  handle: Handle
}
<span class="boring">}
</span></code></pre></pre>
<p>Worker 维护了一个 mpsc channel 的接收端rx，而每个 Buffer Service 维护了一个 mpsc channel 的发送端tx，且 Buffer 实现了 Clone trait，当 Buffer 被 clone 时，对应的 tx 也被clone。</p>
<p>由于用户的 request 是由 Buffer 转交给 Worker 的，因此 request 的处理结果无法直接从 Buffer 获取。这里就体现了 Service trait 的灵活性，由于 Service 的call函数返回的是一个 Future，因此可以自定义一个 ResponseFuture，然后在 Worker 要处理的 Message 中包含一个 channel 的发送端，在call函数返回的 Future 中包含该 channel 的接收端，就可以使得 Worker 和用户之间可以直接通信。这个设计应该说是非常巧妙的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Req, Rsp, F, E&gt; Service&lt;Req&gt; for Buffer&lt;Req, F&gt;
where
  F: Future&lt;Output = Result&lt;Rsp, E&gt;&gt; + Send + 'static,
  E: Into&lt;Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;,
  Req: Send + 'static
{
  type Response = Rsp;
  type Error = Box&lt;dyn std::error::Error + Send + Sync&gt;;
  type Future = ResponseFuture&lt;F&gt;;

  fn call(&amp;mut self, request: Rsp) -&gt; Self::Future {
    let span = tracing::Span::current();//这个不用管
    let (tx, rx) = oneshot::channel();//构建一次性管道用于传输返回结果。
    match self.tx.send_item(Message {request, span, tx}) {
      Ok(_) =&gt; ResponseFuture::new(rx),
      Err(_) =&gt; {}
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="discover-中间件"><a class="header" href="#discover-中间件">Discover 中间件</a></h3>
<p>在前面的 Balance 中间件中提到了 Service 集的概念，有集合，就意味着有集合内元素的变动。各个中间件对于 Service 集合的实现可能并不相同，但是都对外提供了统一的增删接口，这个接口就是 Discover trait。</p>
<p>Discover 为了方便对 Service 集进行管理，要求用户对每个 Service 定义一个唯一的标识符并且实现了 Eq。</p>
<p>对 Service 集的修改主要就是增加和删除，用枚举 Change 表示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Change&lt;K, V&gt; {
  Insert(K, V),
  Remove(K)
}
<span class="boring">}
</span></code></pre></pre>
<p>对于一个维护 Service 集的struct，其对 Service 集的修改选择交给用户，由用户提供一个实现 Discover trait 的 struct，而维护 Service 集的 struct 只需要调用 poll_discover 函数就可以获取外界对 Service 集的修改。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Discover: Sealed&lt;Change&lt;(), ()&gt;&gt; {
  type Key: Eq,
  type Service;
  type Error;
  fn poll_discover(
    self: Pin&lt;&amp;mut self&gt;, 
    cx: &amp;mut Context&lt;'_&gt;
  ) -&gt; Poll&lt;Option&lt;Result&lt;Change&lt;Self::Key, Self::Service&gt;, Self::Error&gt;&gt;&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><em>Tips: 在Rust异步编程中，很多的poll及类似的函数的返回结果都是 Poll&lt;Option&lt;Result&lt;V, E&gt;&gt;&gt; 类型的。这种返回类型可以从结果上反映很多东西，通常用于需要被多次poll的函数。</em></p>
</blockquote>
<ul>
<li><em>Poll::Pending: 暂时没有value返回，和普通的poll函数类似</em></li>
<li><em>Poll::Ready(None): 当前Future结束，不会再yield任何值</em></li>
<li><em>Poll::Ready(Some(Ok(_))): 当前 Future yield 一个值，可能还需要被poll</em></li>
<li><em>Poll::Ready(Some(Err(_))): 当前 Future 产生错误，需要进行处理</em></li>
</ul>
<p><em>这一套规则在很多 Rust 异步编程代码中都有体现，可以看作 Rust 异步编程中的潜规则。</em></p>
<p>值得注意的是，这里的 Sealed 是一个空 trait，并且在crate之外无法访问，但是在 discover 模块中为所有实现了 TryStream 的类型实现了 Sealed</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;K, S, E, D: ?Sized&gt; Sealed&lt;Change&lt;(), ()&gt;&gt; for D
where
    D: TryStream&lt;Ok = Change&lt;K, S&gt;, Error = E&gt;,
    K: Eq,
{}
<span class="boring">}
</span></code></pre></pre>
<p>也就是说，要实现 Discover 首先要实现 TryStream，而在 discover 中也为所有实现了 TryStream 的类型自动实现了 Discover trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;K, S, E, D: ?Sized&gt; Discover for D
where
    D: TryStream&lt;Ok = Change&lt;K, S&gt;, Error = E&gt;,
    K: Eq,
{
    type Key = K;
    type Service = S;
    type Error = E;
​
    fn poll_discover(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Option&lt;Result&lt;D::Ok, D::Error&gt;&gt;&gt; {
        TryStream::try_poll_next(self, cx)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>也就是将 Discover 抽象为流式操作，这样就可以用到很多现成的实现了 Stream 的工具来存储对于 Service 集的修改。</p>
<h3 id="filter-中间件"><a class="header" href="#filter-中间件">Filter 中间件</a></h3>
<p>Filter 顾名思义，对于 request 进行一次筛选，只有符合筛选条件的 request 才会提交给 Service 处理。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Filter&lt;T, U&gt; {
  inner: T,
  predicate: U
}
<span class="boring">}
</span></code></pre></pre>
<p>可以看出，Filter 的初始定义非常自由，Filter 对 predicate 并没有任何限制，但是 Filter 必须要根据 predicate 的返回结果分别处理，所以 Filter 和 predicate 总是相关的。</p>
<p>Filter 只对于当 predicate 实现了 Predicate trait 时实现了 Service trait。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Predicate&lt;Req&gt; {
  type Request;
  fn check(&amp;mut self, request: Request) -&gt; Result&lt;Self::Request, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>实现过程也很有意思，由于call函数要求返回一个 Future，因此当筛选不通过时，需要返回一个立刻返回 Ready(Err(_)) 的 Future</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U, Request&gt; Service&lt;Request&gt; for Filter&lt;T, U&gt;
where
    U: Predicate&lt;Request&gt;,
    T: Service&lt;U::Request&gt;,
    T::Error: Into&lt;BoxError&gt;,
{
    type Response = T::Response;
    type Error = BoxError;
    type Future = ResponseFuture&lt;T::Response, T::Future&gt;;//即future_util::future::Either;
​
    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        self.inner.poll_ready(cx).map_err(Into::into)
    }
​
    fn call(&amp;mut self, request: Request) -&gt; Self::Future {
        ResponseFuture::new(match self.predicate.check(request) {
            Ok(request) =&gt; Either::Right(self.inner.call(request).err_into()),
            Err(e) =&gt; Either::Left(futures_util::future::ready(Err(e))),
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="async-predicate"><a class="header" href="#async-predicate"><strong>async predicate</strong></a></h3>
<p>上面讲的predicate函数并不是异步的，这只适用于一些快速筛选的 Filter，如果 predicate 过程也需要等待IO等适合做成异步的场景，那么应该将 predicate 过程也做成异步形式。因此 Filter 模块还存在一个适用于异步场景的 AsyncFilter。</p>
<p>这就导致在一个 Service 同时存在两种 Future，用户也不知道两种 Future 的先后关系，因此需要将两种 Future 放到一个 AsyncResponseFuture，由 AsyncResponseFuture 协调两个 Future。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum State&lt;F, G&gt; {
  Check {check: F},
  WaitResponse {response: G}
}
struct AsyncResponseFuture&lt;P, S, Request&gt;
where
  P: AsyncPredicate&lt;Request&gt;,
  S: Service&lt;P::Request&gt;
{
  state: State&lt;P::Future, S::Future&gt;,
  service: S
}
<span class="boring">}
</span></code></pre></pre>
<p>AsyncResponseFuture 的 poll 结果由当前 state 决定。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;P, S, Request&gt; Future for AsyncResponseFuture&lt;P, S, Request&gt;
where
    P: AsyncPredicate&lt;Request&gt;,
    S: Service&lt;P::Request&gt;,
    S::Error: Into&lt;crate::BoxError&gt;,
{
    type Output = Result&lt;S::Response, crate::BoxError&gt;;
​
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let mut this = self.project();
​
        loop {
            match this.state.as_mut().project() {
                StateProj::Check { mut check } =&gt; {
                    let request = ready!(check.as_mut().poll(cx))?;
                    let response = this.service.call(request);
                    this.state.set(State::WaitResponse { response });
                }
                StateProj::WaitResponse { response } =&gt; {
                    return response.poll(cx).map_err(Into::into);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="limit-中间件"><a class="header" href="#limit-中间件">Limit 中间件</a></h3>
<p>服务器的处理能力是有限的，如果短时间内到达的 request 过多，可能会导致系统宕机。Limit 中间件用于对 request 进行限制，主要分为两种方式：</p>
<ul>
<li>concurrency: 限制并发处理的 request 数量</li>
<li>rate：限制 request 处理的速率</li>
</ul>
<p>concurrency 很好实现，只需要在 Service 维护一个信号量 semaphore，每要处理一个 request 就获取一个信号量，使得并发处理的数量不会超过信号量的值。</p>
<p>rate 可以表示为每一段时间允许的 request 数量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rate {
  num: u64,
  per: Duration
}
<span class="boring">}
</span></code></pre></pre>
<p>借助 tokio::time::sleep_util future，限制 now 到 now+per 这段时间内的 request 处理数量。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S, Request&gt; Service&lt;Request&gt; for RateLimit&lt;S&gt;
where
  S: Service&lt;Request&gt;
{
  type Response = S::Response;
  type Error = S::Error;
  type Future = S::Future;
  fn call(&amp;mut self, request: Request) -&gt; Self::Future {
    match self.state {
      State::Ready{mut until, mut rem} =&gt; {
        let now = Instant::now();
        if now &gt;= until {
          until = now + self.rate.per();
          rem = self.rate.num();
        }

        if rem &gt; 1 {
          rem -= 1;
          self.state = State::Ready{until, rem};
        } else {
          self.sleep.as_mut().reset(until);
          self.state = State::Limited;
        }

        self.inner.call(request);
      }
      State::Limited =&gt; panic!(&quot;service not ready&quot;)
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="load-中间件"><a class="header" href="#load-中间件">Load 中间件</a></h3>
<p>Load 是用于定量化表示一个 Service 的负载的中间件。调用 Balance layer 的 Service 集就要求 Service 必须实现 Load trait。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Load {
  type Metric: PartialOrd,
  fn load(&amp;self) -&gt; Self::Metric;
}
<span class="boring">}
</span></code></pre></pre>
<p>Load 提供下列三个计算 Service 负载的模块：</p>
<ul>
<li>Constant：将 Service 的 Load 指标设为常数；</li>
<li>PendingRequests: 根据 Service 的 Pending request 的数量作为 Service 的负载指标；</li>
<li>PeakEwma: 峰值移动指数平均算法，将 request 的 rtt 时间作为 Service 的负载指标，rtt 即 request 从被接收到返回 response 中间经历的时间。<br />
同时 Load 维护一个平均 rtt 时间，如果最新 request 的 rtt 大于平均 rtt，则取最新 rtt 作为平均 rtt（这就是峰值移动指数平均法的意思）；如果 rtt 小于平均rtt，则根据最新 rtt 和移动指数平均算法计算平均rtt。</li>
</ul>
<p>第二、第三个模块显然需要追踪每个 request 的运行情况，为了解决这个问题，两个模块在实现 Service trait 的 call 函数时会返回一个 TrackCompletionFuture</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TrackCompletionFuture&lt;F, C, H&gt; {
  #[pin]
  future: F,
  handle: Option&lt;H&gt;,
  completion: C
}
<span class="boring">}
</span></code></pre></pre>
<p>其中，handle 为通知 Service request 已经完成的柄，TrackCompletionFuture 只需要负责在 request 执行完成之后 drop handle，由具体的模块去实现 handle 被 drop 时需要实现的动作。</p>
<p>比如 PeakEwma 模块的 handle 需要追踪从接收 request 到执行完成的时间：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Handle {
  sent_at: Instant,
  decay_ns: f64,
  rtt_estimate: Arc&lt;Mutex&lt;RttEstimate&gt;&gt;
}
impl Drop for Handle {
  fn drop(&amp;mut self) {
    let recv_at = Instant::now();
    if let Ok(mut rtt) = self.rtt_estimate.lock() {
      rtt.update(self.sent_at, recv_at, self.decay_ns);//涉及到PeakEwma算法的实现。
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>至于 PendingRequests 就更简单了，其 handle 直接就是一个 Arc&lt;()&gt; 类型的 wrap，直接调用 Arc 类型的 strong_count 函数就知道当前 Pending 的 request 数量。</p>
<h3 id="loadshed-中间件"><a class="header" href="#loadshed-中间件">LoadShed 中间件</a></h3>
<p>LoadShed 类似于 Rust 中的一些 try_xxx 函数，其 poll_ready 函数返回 <code>Poll&lt;Result&lt;(), E&gt;&gt;</code> 类型，当 poll_ready 被调用时，总是返回 Ready，但是根据里层的类型判断里层 Service 是否真的 Ready，这个中间件适用于一些特殊的场景。</p>
<p>如果在 Service not ready 的情况下调用call函数，则会返回 overloaded 错误。</p>
<h3 id="make-中间件"><a class="header" href="#make-中间件">Make 中间件</a></h3>
<p>Make 中间件是一种产生 Service 的 Service，适用于一些需要产生新的 Service 来进行处理的场景。Tower 给出的例子是 TCP listener，当收到一个新的 TCP 连接时，listener 需要创建一个新的 Service 来处理 TCP stream。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MakeService&lt;Target, Request&gt;: Sealed&lt;(Target, Request)&gt; {
  type Response;
  type Error;
  type Service: Service&lt;Reuquest, Response = Self::Response, Error = Self::Error&gt;;
  type MakeError;
  type Future: Future&lt;Output = Result&lt;Self::Service, Self::MakeError&gt;&gt;;

  fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::MakeError&gt;&gt;;
  fn make_service(&amp;mut self, target: Target) -&gt; Self::Future;
}
<span class="boring">}
</span></code></pre></pre>
<p>MakeService 已经为所有 Response type 为 Service 类型的 Service 自动实现。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;M, S, Target, Request&gt; MakeService&lt;Target, Request&gt; for M
where
    M: Service&lt;Target, Response = S&gt;,
    S: Service&lt;Request&gt;,
{
    type Response = S::Response;
    type Error = S::Error;
    type Service = S;
    type MakeError = M::Error;
    type Future = M::Future;
​
    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::MakeError&gt;&gt; {
        Service::poll_ready(self, cx)
    }
    fn make_service(&amp;mut self, target: Target) -&gt; Self::Future {
        Service::call(self, target)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="service_fn-组件"><a class="header" href="#service_fn-组件"><strong>service_fn 组件</strong></a></h3>
<p>Tower 提供了一个可以快速将一个签名为</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn(req: Request) -&gt; Result&lt;Response, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>的异步函数包装为一个 Service 的函数 service_fn，其就是一个 Make Service。这种包装很简单，因为每个异步函数在调用时编译器会自动生成一个 Future。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ServiceFn&lt;T&gt; {
  f: T
}
impl&lt;T, F, Request, R, E&gt; Service&lt;Request&gt; for ServiceFn&lt;T&gt;
where
    T: FnMut(Request) -&gt; F,
    F: Future&lt;Output = Result&lt;R, E&gt;&gt;,
{
    type Response = R;
    type Error = E;
    type Future = F;
​
    fn poll_ready(&amp;mut self, _: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), E&gt;&gt; {
        Ok(()).into()
    }
    fn call(&amp;mut self, req: Request) -&gt; Self::Future {
        (self.f)(req)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="reconnect-中间件"><a class="header" href="#reconnect-中间件">Reconnect 中间件</a></h3>
<p>Reconnect 是一个可以在发生错误时自动重连的中间件，一个 Reconnect Service 有三种状态：</p>
<ul>
<li>Idle: 暂时没有任何服务连接，当在这个状态 poll_ready 时，需要根据内部的一个 MakeService 中间件创建一个 Service Future 并跳到 Connecting(MakeService::Future) 状态</li>
<li>Connecting: 通过前一步的 Service Future 进行 poll，如果返回 Ready 则跳到 Connected(Service) 状态，如果有错误则跳到 Idle 状态</li>
<li>Connected: 调用内层 Service 的 poll_ready，如果返回错误，则需要重新创建连接，跳到 Idle 状态</li>
</ul>
<p>在 poll_ready 函数中，遇到 Poll::Ready(Ok(<em>)) 或 Poll::Pending 则直接返回，如果遇到 Poll::Ready(Err(</em>)) 则不断循环，直到 Service 正常，因此为 Reconnect。从这一点来看，poll_ready 其实永远不会返回 Poll::Ready(Err(_))，但是为了后续的扩展性，在函数签名上还是有。</p>
<p>Reconnect 如果在非 Connected 状态下调用 call 函数则会 panic。</p>
<h3 id="retry-中间件"><a class="header" href="#retry-中间件">Retry 中间件</a></h3>
<p>Retry 中间件试图将多次里层 Service 的 poll 表现为一次，最简单的场景，对于一个比较繁忙的 Service，单次 poll 可能会返回 Error，于是我可能希望将 Service Future 的一次 poll 表现为里层 Service 每隔一段时间进行一次 poll 进行多次，直到成功返回 Ready 或达到次数限制。Retry 中间件就适用于这些场景。</p>
<p>显然上面只是一种最简单的场景，Tower 为了给予用户最大的 Retry 定制化空间，只需要用户决定是否继续 retry 的类型实现 Policy trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Policy&lt;Req, Res, E&gt;: Sized {
  type Future: Future&lt;Output = Self&gt;;
  fn retry(&amp;self, req: &amp;Req, result: Result&lt;&amp;Res, &amp;E&gt;) -&gt; Option&lt;Self::Future&gt;;
  fn clone_request(&amp;self, req: &amp;Req) -&gt; Option&lt;Req&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>其中 retry 函数用于决定是否应该继续 retry，如果返回 None 则停止，否则返回 Some(Future)。Future 可以在被 poll 时每次生成一个新的实现了 Policy 的 Retry Service，这意味着每次 retry 之后都可以产生新的 Service，而不是只能一直使用同一种 Policy，进一步增大了自由度。</p>
<p>最后再看 Tower 给的 Retry Service 对于 call 函数的 ResponseFuture 的实现。ResponseFuture 包含三种状态：</p>
<ul>
<li>Called(service_future): 可以poll一次里层 Service，如果是 Pending 则直接返回 Pending。否则调用 retry 函数生成一个新的 Retry Service Future，跳到 Checking(retry_future) 状态</li>
<li>Checking(retry_future): 等待 retry_future 生成新的 Retry Service 的中间态，如果生成 Retry Service 则跳到 Retrying 状态</li>
<li>Retrying: 等待里层 Service poll_ready 的中间态，如果里层 Service 已经 Ready，则调用里层 Service 的call函数生成 service_future 并跳到 Called(service_future) 状态</li>
</ul>
<h3 id="spawnready-中间件"><a class="header" href="#spawnready-中间件">SpawnReady 中间件</a></h3>
<p>SpawnReady 在官方文档上的介绍是 &quot;Drive a service to readiness on a background task&quot;。如果我们需要尽快察觉到某个 Service 已经 ready，那我们可能会经常去 poll_ready 一下，而 SpawnReady 就是将这件事包装为一个 Service，并且在内部包装一个 task 用于检查内层 Service 是否 ready。假设 executor 里面只有两个 task，那么一个是真正在做事的 task，另一个则是检查前一个 task 是否 ready 的 task。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S, Req&gt; Service&lt;Req&gt; for SpawnReady&lt;S&gt;
where
    Req: 'static,
    S: Service&lt;Req&gt; + Send + 'static,
    S::Error: Into&lt;BoxError&gt;,
{
    type Response = S::Response;
    type Error = BoxError;
    type Future = ResponseFuture&lt;S::Future, S::Error&gt;;
​
    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), BoxError&gt;&gt; {
        loop {
            self.inner = match self.inner {
                Inner::Service(ref mut svc) =&gt; {
                    if let Poll::Ready(r) = svc.as_mut().expect(&quot;illegal state&quot;).poll_ready(cx) {
                        return Poll::Ready(r.map_err(Into::into));
                    }
                    let svc = svc.take().expect(&quot;illegal state&quot;);
                    let rx =   tokio::spawn(svc.ready_oneshot().map_err(Into::into).in_current_span());
                    Inner::Future(rx)
                }
                Inner::Future(ref mut fut) =&gt; {
                    let svc = ready!(Pin::new(fut).poll(cx))??;
                    Inner::Service(Some(svc))
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过 ready_oneshot 函数将 Service 包装为一个 ReadyOneshot task，然后通过 tokio::spawn 传入 executor</p>
<h3 id="steer-中间件"><a class="header" href="#steer-中间件">Steer 中间件</a></h3>
<p>Steer 中间件用于管理 Service 数组，根据自定义的规则将 request 导向特定的 Service。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Picker&lt;S, Req&gt; {
  fn pick(&amp;mut self, r: &amp;Req, services: &amp;[S]) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<p>由于 Steer 内部维护多个 Service，所以只有多个 Service 同时 ready， Steer 才会返回 Ready。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Steer&lt;S, F, Req&gt; {
  router: F,
  services: Vec&lt;S&gt;,
  not_ready: VecDeque&lt;usize&gt;,
  _phantom: PhantomData&lt;Req&gt;
}
impl&lt;S, Req, F&gt; Service&lt;Req&gt; for Steer&lt;S, F, Req&gt;
where
    S: Service&lt;Req&gt;,
    F: Picker&lt;S, Req&gt;,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = S::Future;
​
    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        loop {
            // must wait for *all* services to be ready.
            // this will cause head-of-line blocking unless the underlying services are always ready.
            if self.not_ready.is_empty() {
                return Poll::Ready(Ok(()));
            } else {
                if self.services[self.not_ready[0]]
                    .poll_ready(cx)?
                    .is_pending()
                {
                    return Poll::Pending;
                }
​
                self.not_ready.pop_front();
            }
        }
    }
​
    fn call(&amp;mut self, req: Req) -&gt; Self::Future {
        assert!(
            self.not_ready.is_empty(),
            &quot;Steer must wait for all services to be ready. Did you forget to call poll_ready()?&quot;
        );
​
        let idx = self.router.pick(&amp;req, &amp;self.services[..]);
        let cl = &amp;mut self.services[idx];
        self.not_ready.push_back(idx);
        cl.call(req)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样的处理实际会拖累整体的效率，如果某个 request 所需要的 Service 实际是 ready 的，但是可能为了等待其他的 Service 而延缓调用。但是为了兼容 Tower 的核心 API 不得不这么处理，毕竟 poll_ready 会与 request 相关的 Service 只有这一个。</p>
<h3 id="结论"><a class="header" href="#结论">结论</a></h3>
<p>Tower 将网络编程中常见的行为抽象为统一的 Service，对外的接口非常统一，并且可以相互叠加，而且是异步式，是一个扩展性非常强大的框架，值得学习一下。</p>
<h1 id="摘自httpszhuanlanzhihucomp548090197"><a class="header" href="#摘自httpszhuanlanzhihucomp548090197">摘自<a href="https://zhuanlan.zhihu.com/p/548090197">https://zhuanlan.zhihu.com/p/548090197</a></a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>(\because\ e^y = x \rightarrow y = \ln x \ \therefore\ e^{\ln x} = x \ \therefore\ e^{\ln x^x} = x^x )</p>
<p>(\huge (uv)^{(n)} = \Sigma^n_{k=0} C^k_n u^{(n-k)}v^{(k)})</p>
<p>(\forall 表示任取)</p>
<h1 id="等价无穷小替换"><a class="header" href="#等价无穷小替换">等价无穷小替换</a></h1>
<p>(\lim\limits_{x\to0}\frac{\tan x - x}{x^2\sin x} = \lim\limits_{x\to0}\frac{\tan x -x}{x^3})</p>
<p>此处 (\sin x) 可以替换为 (x)，(\tan x) 不可替换为 (x)。</p>
<p>因为等价无穷小替换的前提是分子或分母是一些项的乘积，而这里分子不是一些项的乘积，所以分子处不能使用等价无穷小替换；而分母满足条件，可以使用等价无穷小替换</p>
<h1 id="微分公式"><a class="header" href="#微分公式">微分公式</a></h1>
<p>()
\huge dy = f'(x)dx
()</p>
<h1 id="复合函数的微分"><a class="header" href="#复合函数的微分">复合函数的微分</a></h1>
<p>()
\huge y = f(u), , u = g(x) ,\Rightarrow du=g'(x)dx
\
dy = y'_xdx = f'(u)g'(x)dx = f'(u)du \
\Downarrow \ dy = f'(u)du
()</p>
<blockquote>
<p>从上面俩可以得出 <strong>“微分形式不变性”</strong></p>
</blockquote>
<h1 id="微分在近似计算中的应用"><a class="header" href="#微分在近似计算中的应用">微分在近似计算中的应用</a></h1>
<p>(\Delta y = f(x_0+\Delta x) - f(x_0)) <strong>精确值</strong></p>
<p>(dy = f'(x_0)\Delta x)                          <strong>近似值</strong></p>
<p>(\Delta y \approx dy)</p>
<p>(\therefore f(x_0 + \Delta x) \approx f'(x_0)\Delta x + f(x_0))</p>
<blockquote>
<p>例：半径 1 cm 球，镀铜 0.01 cm，求镀的铜的体积</p>
</blockquote>
<p>()
V = \frac{4}{3}\pi r^3, ,,,, r_0 = 1, \Delta r = 0.01 \
V' = 4\pi r^2 
()</p>
<p>目的是求 (\Delta V), (\Delta V) 是精确值。</p>
<p>(\Delta V \approx 4\pi r^2|_{r=1}\Delta r = 4\pi \times 0.01 = 0.04\pi \approx 0.13(cm^3))</p>
<p>要求质量的话再乘以密度即可。</p>
<h2 id="近似计算中的常用公式"><a class="header" href="#近似计算中的常用公式">近似计算中的常用公式</a></h2>
<p>(\LARGE x \to 0 )
(\normalsize (1),,,, \Large (1+x)^\alpha \approx 1 + \alpha x)
(\normalsize (2),,,, \Large sinx \approx x)</p>
<p>(\normalsize (3),,,, \Large tanx \approx x)</p>
<p>(\normalsize (4),,,, \Large e^x \approx 1 + x )</p>
<p>(\normalsize (5),,,, \Large \ln(1+x) \approx x)</p>
<p><strong>意义：</strong></p>
<p><strong>1. 左边的失去计算器没一个好算的，但是右边的都好算。</strong></p>
<p><strong>2. 精确度高</strong></p>
<h1 id="微分中值定理"><a class="header" href="#微分中值定理">微分中值定理</a></h1>
<h2 id="拉格朗日中值定理"><a class="header" href="#拉格朗日中值定理">拉格朗日中值定理</a></h2>
<blockquote>
<ol>
<li>
<p>([a,b],,连续)</p>
</li>
<li>
<p>((a,b),,可导)</p>
</li>
</ol>
<p>((a,b),,)至少有一点 (\xi) 满足:</p>
<p>(f(b) - f(a) = f'(\xi)(b-a) \Rightarrow f'(\xi) = \frac{f(b)-f(a)}{b-a})</p>
</blockquote>
<h2 id="罗尔中值定理"><a class="header" href="#罗尔中值定理">罗尔中值定理</a></h2>
<blockquote>
<ol>
<li>
<p>([a,b],,连续)</p>
</li>
<li>
<p>((a,b),,可导)</p>
</li>
<li>
<p>(f(a) = f(b))</p>
</li>
</ol>
<p>则至少有一个(\xi \in (a,b). f'(\xi) = 0)</p>
</blockquote>
<p>罗尔中值定理是拉格朗日中值定理的一种特殊情况。</p>
<p>从以上可以再推出一个定理：</p>
<p>()
\large f(x) 在区间, I ,连续且可导,同时导数恒为,0,,f(x) = C,(C, 为常数)
()</p>
<h2 id="柯西中值定理"><a class="header" href="#柯西中值定理">柯西中值定理</a></h2>
<blockquote>
<p>(若有,f(x),和,F(x))</p>
<ol>
<li>
<p>([a,b],,连续)</p>
</li>
<li>
<p>((a,b),,可导)</p>
</li>
<li>
<p>(\forall x \in (a,b) 且 F'(x) \neq 0)</p>
</li>
</ol>
<p>(至少有一点 \xi 满足,\frac{f(b)-f(a)}{F(b)-F(a)} = \frac{f'(\xi)}{F'(\xi)})</p>
</blockquote>
<p><strong>柯西中值定理是这几个中值定理里面最一般化的。</strong></p>
<p><strong>柯西中值定理中将 (F(x)=x) 时即可推出拉格朗日中值定理</strong></p>
<p><strong>拉格朗日中值定理中将 (f(a)=f(b)) 即可推出罗尔中值定理</strong></p>
<h1 id="洛必达法则"><a class="header" href="#洛必达法则">洛必达法则</a></h1>
<blockquote>
<ol>
<li>
<p>(x\to a时, f(x)\to 0,,F(x)\to 0)</p>
</li>
<li>
<p>(在,a,的去心邻域内,f'(x),,F'(x),存在且,F'(x)\neq 0)</p>
</li>
<li>
<p>(\lim\limits_{x\to a}\frac{f'(x)}{F'(x)}存在(或\infty))</p>
</li>
</ol>
<p>(则,,\lim\limits_{x\to a}\frac{f(x)}{F(x)} = \lim\limits_{x\to a}\frac{f'(x)}{F'(x)})</p>
</blockquote>
<blockquote>
<ol>
<li>
<p>(x\to \infty时, f(x)\to 0,,F(x)\to 0)</p>
</li>
<li>
<p>(在,a,的去心邻域内,f'(x),,F'(x),存在且,F'(x)\neq 0)</p>
</li>
<li>
<p>(\lim\limits_{x\to a}\frac{f'(x)}{F'(x)}存在(或\infty))</p>
</li>
</ol>
<p>(则,,\lim\limits_{x\to a}\frac{f(x)}{F(x)} = \lim\limits_{x\to a}\frac{f'(x)}{F'(x)})</p>
</blockquote>
<p>(\frac{0}{0},,\frac{\infty}{\infty},,0\cdot\infty,\infty-\infty,, 0^0,,1^\infty,,\infty^0)</p>
<p><strong>上面这几种情况都可以通过转换成 (\frac{0}{0}或\frac{\infty}{\infty}) 的形式来使用洛必达法则</strong></p>
<p>例如:</p>
<p>(0\cdot\infty的情况:)</p>
<p>(\large \lim\limits_{x\to0^+}x^n \ln x,(n&gt;0) = \lim\limits_{x\to0^+}\frac{lnx}{\frac{1}{x^n}} = \lim\limits_{x\to0^+}\frac{\frac{1}{x}}{-n\cdot x^{-n-1}} = \lim\limits_{x\to0^+}-\frac{1}{nx^{-n}} = \lim\limits_{x\to0^+}-\frac{x^n}{n} = 0)</p>
<p><strong>2 种技巧：</strong></p>
<ul>
<li>
<p>等价无穷小替换</p>
</li>
<li>
<p>适当的将项(<strong>常数或者趋于常数</strong>)朝外挪</p>
</li>
</ul>
<p>比如(\large\lim\limits_{x\to0}\frac{x^2-\tan x}{\cos x\sin x}中,\cos x 趋于,0，所以可以转换成,,1\cdot \lim\limits_{x\to0}\frac{x^2-\tan x}{\sin x})</p>
<h1 id="泰勒公式"><a class="header" href="#泰勒公式">泰勒公式</a></h1>
<p>()
f(x),在,x_0,处有,n,阶导，\exist x_0的一个邻域,则有:\
f(x)=f(x_0) + \frac{f'(x_0)}{1!}(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 +\ldots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n +R_n(x)\
Rn(x) = \circ(\small{(x-x_0)^n})，即是高阶无穷小 \
Rn(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}, \xi,介于,x_0,与,x,之间 
()</p>
<h1 id="麦克劳林公式"><a class="header" href="#麦克劳林公式">麦克劳林公式</a></h1>
<p>一般用的比较多的是泰勒公式在 (x_0 = 0) 处展开,那么就有了麦克劳林公式：</p>
<p>()
x_0 = 0,,f(x) = f(0) + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2+\ldots+
\frac{f^{(n)}(0)}{n!}x^n + \frac{f^{(n+1)}(\theta x)}{(n+1)!}x^{n+1},,\
0&lt;\theta&lt;1
()</p>
<h2 id="用麦克劳林公式解释等价无穷小"><a class="header" href="#用麦克劳林公式解释等价无穷小">用麦克劳林公式解释等价无穷小</a></h2>
<blockquote>
<p>解释 (e^x-1 \sim x)</p>
</blockquote>
<p>()
f(x)=e^x,f'(x)=f''(x)=\ldots=f^{(n)}(x)=e^x,f^{(n+1)}(\theta x) = e^{\theta x}\
\because e^x=1+x+\frac{1}{2!}x^2+\frac{1}{3!}x^3 +\ldots+\frac{1}{n!}x^n+\frac{e^{\theta x}}{(n+1)!}x^{n+1},
0&lt;\theta&lt;1\
e^x \approx 1+x+\frac{1}{2!}x^2+\frac{1}{3!}x^3 +\ldots+\frac{1}{n!}x^n\
\therefore 当,x\to0,时，x^2,以及更高次可以忽略不计，就有了\
e^x\sim1+x \Rightarrow e^x-1 \sim x
()</p>
<h1 id="不定积分"><a class="header" href="#不定积分">不定积分</a></h1>
<p>()
\Large \int f(x)dx = F(x) + C \
f(x),为被积函数，dx,为积分变量。
()()
F'(x) = f(x)\
F(x)为原函数,f(x)为导函数
()</p>
<p>求谁的原函数，谁就是被积函数。</p>
<h2 id="积分表求导表"><a class="header" href="#积分表求导表">积分表/求导表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>积分表</th><th>求导表</th></tr></thead><tbody>
<tr><td>(\int kdx=kx+C)</td><td>((kx)'=k)</td></tr>
<tr><td>(\int x^udx=\frac{x^{u+1}}{u+1}+C)</td><td>((x^u)'=ux^{u-1})</td></tr>
<tr><td>(\int\frac{1}{x}dx=\ln\</td><td>x\</td></tr>
<tr><td>(\int\frac{dx}{1+x^2}=\arctan x+C)</td><td>(x&gt;0,(\arctan x)'=\frac{1}{1+x^2})</td></tr>
<tr><td>(\int\frac{dx}{\sqrt{1-x^2}}=\arcsin x+C)</td><td>((\arcsin x)'=\frac{1}{\sqrt{1-x^2}})</td></tr>
<tr><td>(\int\cos xdx=\sin x+C)</td><td>((\sin x)'=\cos x)</td></tr>
<tr><td>(\int\sin xdx=-\cos x+C)</td><td>((\cos x)'=-\sin x)</td></tr>
<tr><td>(\int \tan xdx=-\ln\</td><td>\cos x\</td></tr>
<tr><td>(\int \cot xdx=\ln\</td><td>\sin x\</td></tr>
<tr><td>(\int \csc xdx=\ln\</td><td>\tan\frac{x}{2}\</td></tr>
<tr><td>(\int\sec xdx=\ln\</td><td>\sec x+\tan x\</td></tr>
<tr><td>(\int\frac{dx}{a^2+x^2}=\frac{1}{a}\arctan\frac{x}{a}+C)</td><td></td></tr>
<tr><td>(\int\frac{dx}{x^2-a^2}=\frac{1}{2a}\ln\</td><td>\frac{x-a}{x+a}\</td></tr>
<tr><td>(\int\frac{dx}{\cos^2x}=\int\sec^2xdx=\tan x+C)</td><td>((\tan x)'=\frac1{\cos^2x})</td></tr>
<tr><td>(\int\frac{dx}{\sin^2x}=\int\csc^2dx=-\cot x+C)</td><td>((\cot x)'=-(\csc^2x))</td></tr>
<tr><td>(\int\sec x\tan xdx=\sec x+C)</td><td>((\sec x)'=\sec x\tan x)</td></tr>
<tr><td>(\int\csc^2\cot x dx=-\csc x+C)</td><td>((\csc x)' = -\csc x\cot x)</td></tr>
<tr><td>(\int e^xdx=e^x+C)</td><td>((e^x)'=e^x)</td></tr>
<tr><td>(\int a^xdx=\frac{a^x}{\ln a}+C)</td><td>((a^x)'=a^x\ln a)</td></tr>
</tbody></table>
</div>
<h2 id="第二类换元积分法一般的替换模式"><a class="header" href="#第二类换元积分法一般的替换模式">第二类换元积分法一般的替换模式</a></h2>
<ol>
<li>
<p>(\sqrt{a^2-x^2},,,,x=a\sin t,(此处都需要加上t取值范围),,,,\sqrt{a^2-a^2\sin^2t}=\sqrt{a^2\cos^2t})</p>
</li>
<li>
<p>(\sqrt{x^2-a^2},,,,x=a\sec t,,,,\sqrt{a^2\sec^2t-a^2}=\sqrt{a^2\tan^2t})</p>
</li>
<li>
<p>(\sqrt{x^2+a^2},,,,x=a\tan t,,,,\sqrt{a^2\tan^2t+a^2}=\sqrt{a^2\sec^2t})</p>
</li>
</ol>
<h1 id="分部积分法"><a class="header" href="#分部积分法">分部积分法</a></h1>
<p>()
\int udv=uv-\int vdu
()</p>
<p>向 (d) 后面拿的优先级：</p>
<ol>
<li>
<p>(e^x)</p>
</li>
<li>
<p>(\sin \cos)</p>
</li>
<li>
<p>(x^n)</p>
</li>
</ol>
<p>用分部积分做题很少有一次分部积分公式就搞定的，基本上要2次及以上。</p>
<p><strong>用分部积分法解题的常见现象，要求的东西分部积分求着求着又出现了：</strong></p>
<p>()
看系数\begin{cases}
+1 说明做错了 \Rightarrow检查\
其它 \Rightarrow基本没问题，把左右两边一样的合并
\end{cases}
()</p>
<blockquote>
<p>使用分部积分法求 (\ln x原函数)</p>
</blockquote>
<p>(\int\ln xdx=x\ln x-\int xd\ln x=x\ln x-\int1dx=x\ln x-x+C)</p>
<h1 id="微积分基本公式"><a class="header" href="#微积分基本公式">微积分基本公式</a></h1>
<p>()
[\int^{\phi(x)}_{\psi(x)}f(t)dt]'=f({\phi(x)})\phi'(x)-f({\psi(x)})\psi'(x)
()</p>
<h1 id="定积分基本公式"><a class="header" href="#定积分基本公式">定积分基本公式</a></h1>
<h2 id="牛顿-莱布尼茨公式"><a class="header" href="#牛顿-莱布尼茨公式">牛顿-莱布尼茨公式</a></h2>
<p>()
F(x)是f(x)的原函数。\
\int^b_af(x)dx=F(x)|^b_a=F(b)-F(a)
()</p>
<h2 id="定积分换元法"><a class="header" href="#定积分换元法">定积分换元法</a></h2>
<p><strong>定理：</strong></p>
<p>()
\begin{align*}
&amp;x=\phi(t) \
&amp;1),,,,\phi(\alpha)=a,\phi(\beta)=b \
&amp;\int_a^bf(x)dx=\int_\alpha^\beta f({\phi(t)})\phi(t)dt
\end{align*}
()</p>
<ol>
<li>
<p>引入换元函数</p>
</li>
<li>
<p>上下限也跟变</p>
</li>
</ol>
<p><strong>例题：</strong></p>
<p>()
\begin{align*}
&amp;1)\int_0^a\sqrt{a^2-x^2},dx,,(a&gt;0)\
&amp;解:\
&amp;x=a\sin t,,dx=a\cos t,dt,,x=0\to t=0,,x=a\to t=\frac{\pi}{2}\
&amp;\therefore \int_0^a\sqrt{a^2-x^2},dx\
&amp;=\int_0^{\frac{\pi}{2}}\sqrt{a^2-a^2\sin^2t}
,a\cos t,dt\&amp;=\int_0^{\frac{\pi}{2}}a^2\cos^2t,dt\
&amp;=\frac{1}{2}\int_0^{\frac{\pi}{2}}a^2+a^2\cos 2t,dt\
&amp;=\frac{\pi}{4}a^2
\end{align*}
()</p>
<blockquote>
<p>特殊结论</p>
</blockquote>
<p>()
\begin{align*}
&amp;[-a,a],,,,f(x)为偶函数时，\int_{-a}^af(x)dx=2\int_0^af(x)dx\
&amp;[-a,a],,,,f(x)为奇函数时，\int_{-a}^af(x)dx=0
\end{align*}
()</p>
<h1 id="一阶线性微分方程"><a class="header" href="#一阶线性微分方程">一阶线性微分方程</a></h1>
<p>()
\frac{dy}{dx} + P(x)y = Q(x) \
(Q(x)=0表示齐次)\
齐次、非齐次通用公式：\
\huge\Downarrow\
\huge y=e^{-\int P(x)dx}(\int Q(x)e^{\int P(x)dx}dx+C)
()</p>
<h1 id="常系数线性齐次微分方程"><a class="header" href="#常系数线性齐次微分方程">常系数线性齐次微分方程</a></h1>
<h2 id="二阶常系数线性齐次微分方程"><a class="header" href="#二阶常系数线性齐次微分方程">二阶常系数线性齐次微分方程</a></h2>
<p>()
\begin{align*}
&amp;y'' + py' + qy = 0 \
&amp;y称为其通解 \
&amp; 做法是将其转化为特征方程 \Longrightarrow r^2 + pr + q =0 \
&amp;\begin{cases}
① \Delta=p^2-4q &gt; 0,r_1=\frac{-p+\sqrt{\Delta}}{2}, r_2=\frac{-p-\sqrt{\Delta}}{2}, 
&amp;y=C_1e^{r_1x} + C_2e^{r_2x}\
② \Delta=p^2-4q = 0,r_1=r_2=\frac{-p}{2}, &amp;y=(C_1+C_2x)e^{r_1x} \
③ \Delta=p^2-4q &lt; 0,r_1=\alpha+\beta i,r_2=\alpha-\beta i, &amp;y=e^{\alpha x}
(C_1\cos \beta x + C_2\sin \beta x)
\end{cases}
\end{align*}
()</p>
<h1 id="无穷级数"><a class="header" href="#无穷级数">无穷级数</a></h1>
<h2 id="常数项级数"><a class="header" href="#常数项级数">常数项级数</a></h2>
<blockquote>
<p>等比（几何）级数</p>
</blockquote>
<p>()
\large a+aq+aq^2+aq^3+\cdot\cdot\cdot+aq^{n-1}+\cdot\cdot\cdot
()()
\begin{align*}
&amp;S_n为前n项和 \
&amp;①|q|\neq 1 ,,,, S_n=\frac{a(1-q^n)}{1-q}
\begin{cases}
|q|&lt;1 \lim\limits_{n\to\infty}S_n=\frac{a}{1-q} \
|q|&gt;1 \lim\limits_{n\to\infty}S_n发散\
\end{cases} \
&amp;②|q|=1
\begin{cases}
q=1 发散\
q=-1 发散\
\end{cases}\
&amp;结论: 
\begin{cases}
|q|&lt;1 收敛\
|q|\geq1发散
\end{cases}
\end{align*}
()</p>
<blockquote>
<p>性质1)</p>
<p>()
\large \sum^\infty_{n=1}U_n收敛于S, \sum^\infty_{n=1}kU_n收敛于kS
()</p>
</blockquote>
<blockquote>
<p>性质2)</p>
<p>()
\large \sum^\infty_{n=1}U_n和\sum^\infty_{n=1}V_n分别收敛于 S 和\sigma.\
\sum^\infty_{n=1}(U_n\pm V_n)也收敛.和S\pm\sigma</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p>正推可以，反推不可以。</p>
<blockquote>
<p>性质3)</p>
<p>()
去掉、加上或改变有限项，敛散性不变（注意不是和不变）
()</p>
</blockquote>
<blockquote>
<p>性质4)</p>
<p>()
\large \sum U_n收敛，任意加括号得级数也收敛，且和不变。
()</p>
</blockquote>
<p>正推可以，反推不可以</p>
<p><strong>但是，加括号后发散的，原级数一定发散</strong></p>
<blockquote>
<p>性质5)</p>
<p>()
\begin{align*}
\large \sum &amp;U_n收敛，U_n \to 0.\
\because &amp;U_n=S_n-S_{n-1} \
&amp;S_n \to S \
&amp;S_{n-1} \to S \
\therefore &amp;U_n \to 0
\end{align*}
()</p>
</blockquote>
<p>正推可以，反推不可以</p>
<p>性质5的逆否命题（为真）做题时很有用</p>
<blockquote>
<p>()
U_n \nrightarrow 0,\sum U_n 发散
()</p>
</blockquote>
<h2 id="调和级数"><a class="header" href="#调和级数">调和级数</a></h2>
<p>调和级数是个发散的级数，因为项跟项之间的和增大的速度大于后面项趋于0的速度</p>
<p>例子:</p>
<p>()
1+\frac1{2}+\frac1{3}+\cdot\cdot\cdot+\frac1{n}+\cdot\cdot\cdot是发散的
()</p>
<h2 id="正项级数"><a class="header" href="#正项级数">正项级数</a></h2>
<p>(U_n \geq 0)</p>
<p>(S_1\leq S_2\leq S_3,\cdot\cdot\cdot)</p>
<p>({S_n} \geq 0)</p>
<blockquote>
<p><strong>定理1</strong></p>
<p>()
\begin{align*}
&amp;前提都是正项级数\
&amp;\sum U_n 收敛 \Leftrightarrow {S_n}有界\
\end{align*}
()</p>
</blockquote>
<blockquote>
<p><strong>定理2</strong></p>
<p>()
\begin{align*}
\sum U_n,\sum V_n是正项级数，且U_n \leq V_n
\begin{cases}
\sum V_n 收敛 \to \sum U_n 收敛\
\sum U_n 发散 \to \sum V_n 发散\
\end{cases}
\end{align*}
()</p>
</blockquote>
<h3 id="p一级数"><a class="header" href="#p一级数">P一级数</a></h3>
<p>()
1+\frac{1}{2^p}+\frac{1}{3^p}+\cdot\cdot\cdot\frac{1}{n^p}+\cdot\cdot\cdot
()</p>
<p>结论：</p>
<p>()
① p \leq1,发散\
② p &gt;1,收敛
()()
\frac{1}{k^p}=\int^k_{k-1}\frac1{k^p}dx\leq\int^k_{k-1}\frac1{x^p}dx
()()
S_n=1+\sum^n_{k=2}\frac1{k^p}\leq 1+\sum^n_{k-1}\frac1{x^p}dx=1+\int^n_1\frac1{x^p}dx
=1+\frac1{p-1}(1-\frac1{n^{p-1}})&lt;1+\frac1{p-1}\
\therefore S_n 有界
()</p>
<h3 id="正项级数的比较审敛法"><a class="header" href="#正项级数的比较审敛法">正项级数的比较审敛法</a></h3>
<h4 id="极限改进的比较审敛法"><a class="header" href="#极限改进的比较审敛法">极限改进的比较审敛法：</a></h4>
<p>(\sum U_n和\sum V_n都是正项级数)</p>
<blockquote>
<p>定理1：</p>
<p>()
\lim\limits_{n\to\infty}\frac{U_n}{V_n}=l,(0\leq l &lt; +\infty) \Rightarrow
\sum V_n 收敛，\sum U_n 收敛
()</p>
</blockquote>
<blockquote>
<p>定理2：</p>
<p>()
\lim\limits_{n\to \infty}\frac{U_n}{V_n}=l &gt; 0 或 +\infty \Rightarrow
\sum V_n 发散，\sum U_n 发散
()</p>
</blockquote>
<h3 id="正项级数的比值审敛法"><a class="header" href="#正项级数的比值审敛法">正项级数的比值审敛法</a></h3>
<blockquote>
<p>定理</p>
<p>()
\lim\limits_{n\to\infty}\frac{U_{n+1}}{U_n}=\rho\
\rho &lt; 1 收敛，\rho &gt; 1 (包含+\infty)发散
()</p>
<p>缺点是 (\rho = 1)时无法判断，优点是不需要跟比较审敛法一样找一个比较对象</p>
</blockquote>
<h3 id="正向级数的根值审敛法柯西判别法"><a class="header" href="#正向级数的根值审敛法柯西判别法">正向级数的根值审敛法（柯西判别法）</a></h3>
<blockquote>
<p>定理</p>
<p>()
\lim\limits_{n\to\infty}\sqrt[n]{U_n}=\rho \
\begin{align*}
1)&amp; \rho &lt; 1 收敛 \
2)&amp; \rho &gt; 1 发散 \
3)&amp; \rho = 1 无法确定（同比值审敛法，本方法失效）
\end{align*}
()</p>
</blockquote>
<h2 id="交错级数"><a class="header" href="#交错级数">交错级数</a></h2>
<p>()
\begin{align*}
&amp;U_n \geq 0\
&amp;U_1-U_2+U_3-U_4+\cdot\cdot\cdot \
&amp;-U_1+U_2-U_3+U_4+\cdot\cdot\cdot \
\sum^\infty_{n=1}(-1)^{n-1}U_n
\end{align*}
()</p>
<blockquote>
<p>莱布尼茨定理</p>
<p>()
\begin{align*}
&amp;1) U_n \geq U_{n+1}\
&amp;2) \lim\limits_{n\to\infty} U_n = 0\
则级数收敛，S \leq U_1,并且余项|r_n|\leq U_{n+1}
\end{align*}
()</p>
</blockquote>
<h2 id="任意项级数"><a class="header" href="#任意项级数">任意项级数</a></h2>
<p>()
\begin{align*}
&amp;任意项级数：U_1+U_2+U_3+\cdot\cdot\cdot&amp; (U_n正负不知道)\
&amp;正项级数：|U_1|+|U_2|+|U_3|+\cdot\cdot\cdot&amp; (绝对值级数)\
\end{align*}
()</p>
<blockquote>
<p>定理：</p>
<p>()
\sum^{+\infty}<em>{n=1}|U_n|收敛，则\sum^{+\infty}</em>{n=1}U_n也收敛
()</p>
</blockquote>
<p>()
\begin{align*}
&amp;绝对收敛： \sum |U_n|收敛，称\sum U_n绝对收敛 \
&amp;条件收敛： \sum U_n收敛，\sum |U_n|发散，\sum U_n是条件收敛
\end{align*}
()</p>
<blockquote>
<p>定理：</p>
<p>()
\sum^{+\infty}_{n=1}U_n=U_1+U_2+U_3+\cdot\cdot\cdot是任意项级数\</p>
</blockquote>
<p>\lim\limits_{n\to +\infty}|\frac{U_n+1}{U_n}|=l \longleftarrow
正项级数的比值审敛法\
①: l &lt; 1 时，\sum U_n(绝对)收敛\
②：l &gt; 1 (+\infty)时，\sum U_n 发散
③：l = 1 时，本方法无法判断</p>
<blockquote>
<p>()</p>
</blockquote>
<h2 id="幂级数"><a class="header" href="#幂级数">幂级数</a></h2>
<p>()
1+x+x^2+x^3+\cdot\cdot\cdot+x^n+\cdot\cdot\cdot
\begin{cases}
|x|&lt;1时，收敛域(-1,1),和是\frac{a}{1-q}=\frac1{1-x}\
|x| \geq 1 时，发散域(-\infty,-1]\cup[1,+\infty)
\end{cases}
()</p>
<blockquote>
<p>定理（阿贝尔定理）</p>
<p>()
\sum^{+\infty}_{n=0}a_nx^n,
\begin{cases}
如果x=x_0时收敛，则|x|&lt;|x_0|时幂级数绝对收敛\
如果x=x_0时收敛，则|x|&gt;|x_0|时幂级数发散
\end{cases}
()</p>
</blockquote>
<blockquote>
<p>推论：</p>
<p>()
收敛情况
\begin{cases}
①:x=0时收敛,例如\sum n!x^n\
②:x\in(-\infty,+\infty)时收敛,例如\sum \frac{x^n}{n!}\
③:|x|&lt;R绝对收敛(但是在-R跟R这两个端点的情况就需要另外讨论)\
\end{cases}
()</p>
</blockquote>
<p>()
\begin{align*}
&amp;(R&gt;0)R叫作收敛半径，(-R,R)叫收敛区间\
&amp;[-R,R),[-R,R],(-R,R),(-R,R]这四种叫收敛域\
&amp;收敛区间不包括端点，收敛域需要在讨论完端点的情况后决定是否将端点加进来
\end{align*}
()</p>
<h3 id="如何求-r"><a class="header" href="#如何求-r">如何求 R?</a></h3>
<blockquote>
<p>定理</p>
<p>()
\begin{align*}
&amp;\lim\limits_{n\to\infty}|\frac{a_{n+1}}{a_n}|=\rho\
&amp;R=
\begin{cases}
\frac1{\rho},,,,&amp;\rho\neq0\
+\infty,,,,&amp;\rho=0\
0,,,,&amp;\rho=+\infty
\end{cases}
&amp;其实可以只记R=\frac1{\rho}
\end{align*}
()</p>
</blockquote>
<h3 id="幂级数的运算"><a class="header" href="#幂级数的运算">幂级数的运算</a></h3>
<p>()
\begin{align*}
&amp;性质1)\sum^{+\infty}<em>{n=0}a_nx^n的和函数S(x)在收敛域I上是连续的 \
&amp;性质2)\sum^{+\infty}</em>{n=0}a_nx^n的和函数S(x)在收敛域I上是可积的,例如\int^x_0S(t)dt&amp;=
\int^x_0 \sum^{+\infty}<em>{n=0}(a_nt^n)dt \
&amp;&amp;=\sum^{+\infty}</em>{n=0}\int^x_0 a_nt^ndt ,,,\
&amp;逐项求积分后与原幂级数的收敛半径相同，但收敛域就需要重新考察端点情况 \
&amp;性质3),,S(x)在(-R,R)内可导,S'(x)=(\sum^{+\infty}<em>{n=0}a_nx^n)'=
\sum^{+\infty}</em>{n=0}(a_nx^n)'=\sum^{+\infty}_{n=0}na_nx^{n-1}\
&amp;逐项求导后与原幂级数的收敛半径相同，但收敛域就需要重新考察端点情况 \
\end{align*}
()</p>
<h3 id="函数展成幂级数"><a class="header" href="#函数展成幂级数">函数展成幂级数</a></h3>
<blockquote>
<p>直接展开法：</p>
<p>就是直接用麦克劳林公式展开</p>
</blockquote>
<blockquote>
<p>间接展开法:</p>
<p>就是利用已有的进行展开，做题一般都用这个</p>
<p>记忆：</p>
<p>()
\begin{align*}
①&amp;e^x=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdot\cdot\cdot+\frac{x^n}{n!}+
\cdot\cdot\cdot (-\infty&lt;x&lt;+\infty) \
②&amp;\sin x = x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdot\cdot\cdot+
(-1)^n\frac{x^{2n+1}}{(2n+1)!}+\cdot\cdot\cdot(-\infty&lt;x&lt;+\infty)\
③&amp;\frac1{1-x}=1+x+x^2+x^3+\cdot\cdot\cdot+x^n+\cdot\cdot\cdot(-1&lt;x&lt;1)\
④&amp;\frac1{1+x}=1-x+x^2-x^3+\cdot\cdot\cdot+(-1)^nx^n+\cdot\cdot\cdot(-1&lt;x&lt;1)\
&amp;0到x求积分\huge\Downarrow \
⑤&amp;\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+\cdot\cdot\cdot+
\frac{(-1)^{n-1}}{n}x^n+\cdot\cdot\cdot(-1&lt;x\leq1)\
⑥&amp;\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdot\cdot\cdot+
(-1)^n\frac{x^{2n}}{(2n)!}+\cdot\cdot\cdot(-\infty&lt;x&lt;+\infty)\
⑦&amp;a^x=1+x\ln a + \frac{x^2(\ln a)^2}{2!}+ \frac{x^3(\ln a)^3}{3!}+
\cdot\cdot\cdot+ \frac{x^n(\ln a)^n}{n!}+\cdot\cdot\cdot(-\infty&lt;x&lt;+\infty)\
⑧&amp;\frac{1}{1+x^2}=1-x^2+x^4-x^6+x^8+(-1)^nx^{2n}+\cdot\cdot\cdot(-1&lt;x&lt;1)\
⑨&amp;\arctan x=x-\frac{x^3}{3}+\frac{x^5}{5}-\frac{x^7}{7}+\cdot\cdot\cdot+
(-1)^n\frac{x^{2n+1}}{2n+1}+\cdot\cdot\cdot(-1\leq x\leq1)
\end{align*}
()</p>
</blockquote>
<h1 id="向量和解析几何"><a class="header" href="#向量和解析几何">向量和解析几何</a></h1>
<h2 id="平面夹角"><a class="header" href="#平面夹角">平面夹角</a></h2>
<p>()
n_1(A_1,B_1,C_1),n_2(A_2,B_2,C_2)为两平面各自的法向量。\
\cos\theta=\frac{|A_1A_2+B_1B_2+C_1C_2|}{\sqrt{A_1^2+B_1^2+C_1^2}\sqrt{A_2^2+B_2^2+C_2^2}}
\begin{cases}
①：垂直, A_1A_2+B_1B_2+C_1C_2=0\
②：平行或重合,\frac{A_1}{A_2}=\frac{B_1}{B_2}=\frac{C_1}{C_2} \
\end{cases}
()</p>
<h2 id="距离公式"><a class="header" href="#距离公式">距离公式</a></h2>
<p>()
P_0(x_0,y_0,z_0),Ax+By+Cz+D=0 \
d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}
()</p>

                    <div id="giscus-container"></div>
                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
        </nav>

    </div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
    </script>


    <!-- Custom JS scripts -->
    <script type="text/javascript" src="assets/custom.js"></script>
    <script type="text/javascript" src="assets/bigPicture.js"></script>
    <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>
</body>

</html>